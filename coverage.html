
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs_gen: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/wombatwisdom/wombat/cmd/docs_gen/compat.go (26.9%)</option>
				
				<option value="file1">github.com/wombatwisdom/wombat/cmd/docs_gen/main.go (5.1%)</option>
				
				<option value="file2">github.com/wombatwisdom/wombat/cmd/wombat/main.go (0.0%)</option>
				
				<option value="file3">github.com/wombatwisdom/wombat/internal/docs/docs.go (0.0%)</option>
				
				<option value="file4">github.com/wombatwisdom/wombat/internal/docs/scanner.go (0.0%)</option>
				
				<option value="file5">github.com/wombatwisdom/wombat/internal/impl/snowflake/output_snowflake_put.go (1.3%)</option>
				
				<option value="file6">github.com/wombatwisdom/wombat/internal/impl/splunk/init.go (0.0%)</option>
				
				<option value="file7">github.com/wombatwisdom/wombat/public/components/gcp_bigtable/output.go (63.0%)</option>
				
				<option value="file8">github.com/wombatwisdom/wombat/public/components/mongodb/change_stream/change_stream_input.go (0.0%)</option>
				
				<option value="file9">github.com/wombatwisdom/wombat/public/components/mongodb/change_stream/change_stream_reader.go (0.0%)</option>
				
				<option value="file10">github.com/wombatwisdom/wombat/public/components/mongodb/config.go (0.0%)</option>
				
				<option value="file11">github.com/wombatwisdom/wombat/public/components/nats/auth.go (41.8%)</option>
				
				<option value="file12">github.com/wombatwisdom/wombat/public/components/nats/connection.go (8.0%)</option>
				
				<option value="file13">github.com/wombatwisdom/wombat/public/components/nats/docs.go (100.0%)</option>
				
				<option value="file14">github.com/wombatwisdom/wombat/public/components/nats/errors.go (0.0%)</option>
				
				<option value="file15">github.com/wombatwisdom/wombat/public/components/nats/input_jetstream.go (2.1%)</option>
				
				<option value="file16">github.com/wombatwisdom/wombat/public/components/nats/output_jetstream.go (3.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/redpanda-data/benthos/v4/public/bloblang"
        "github.com/redpanda-data/benthos/v4/public/service"
        "regexp"
        "strings"
)

var (
        reHeader1 = regexp.MustCompile(`(?m)^== `)
        reHeader2 = regexp.MustCompile(`(?m)^=== `)
        reHeader3 = regexp.MustCompile(`(?m)^==== `)
        reHeader4 = regexp.MustCompile(`(?m)^===== `)

        typo_1 = regexp.MustCompile(`&lt;(.*),(.*)&gt;&gt;`)
)

var replacements = map[*regexp.Regexp]string{
        reHeader1: "## ",
        reHeader2: "### ",
        reHeader3: "#### ",
        reHeader4: "##### ",
        typo_1:    "&lt;&lt;$1,$2&gt;&gt;",
}

func parsePluginTemplateData(data service.TemplateDataPlugin) service.TemplateDataPlugin <span class="cov0" title="0">{
        data.Description = correctString(data.Description)
        data.Summary = correctString(data.Summary)
        data.Footnotes = correctString(data.Footnotes)

        for i, field := range data.Fields </span><span class="cov0" title="0">{
                data.Fields[i] = parsePluginFieldTemplateData(field)
        }</span>

        <span class="cov0" title="0">for i, example := range data.Examples </span><span class="cov0" title="0">{
                data.Examples[i].Summary = correctString(example.Summary)
        }</span>

        <span class="cov0" title="0">return data</span>
}

func parsePluginFieldTemplateData(data service.TemplateDataPluginField) service.TemplateDataPluginField <span class="cov0" title="0">{
        data.Description = correctString(data.Description)

        for i, str := range data.ExamplesMarshalled </span><span class="cov0" title="0">{
                data.ExamplesMarshalled[i] = correctString(str)
        }</span>

        <span class="cov0" title="0">for i, str := range data.Options </span><span class="cov0" title="0">{
                data.Options[i] = correctString(str)
        }</span>

        <span class="cov0" title="0">for i, atrArr := range data.AnnotatedOptions </span><span class="cov0" title="0">{
                atrArr[0] = correctString(atrArr[0])
                atrArr[1] = correctString(atrArr[1])
                data.AnnotatedOptions[i] = atrArr
        }</span>

        <span class="cov0" title="0">return data</span>
}

func parseTemplateFunctionData(data bloblang.TemplateFunctionData) bloblang.TemplateFunctionData <span class="cov0" title="0">{
        data.Description = correctString(data.Description)
        data.Params = parseTemplateParamsData(data.Params)

        for i, example := range data.Examples </span><span class="cov0" title="0">{
                data.Examples[i] = parseTemplateExampleData(example)
        }</span>

        <span class="cov0" title="0">return data</span>
}

func parseTemplateMethodData(data bloblang.TemplateMethodData) bloblang.TemplateMethodData <span class="cov0" title="0">{
        data.Description = correctString(data.Description)
        data.Params = parseTemplateParamsData(data.Params)

        for i, example := range data.Examples </span><span class="cov0" title="0">{
                data.Examples[i] = parseTemplateExampleData(example)
        }</span>

        <span class="cov0" title="0">return data</span>
}

func parseTemplateExampleData(data bloblang.TemplateExampleData) bloblang.TemplateExampleData <span class="cov0" title="0">{
        data.Summary = correctString(data.Summary)
        return data
}</span>

func parseTemplateParamsData(data bloblang.TemplateParamsData) bloblang.TemplateParamsData <span class="cov0" title="0">{
        for i, param := range data.Definitions </span><span class="cov0" title="0">{
                data.Definitions[i] = parseTemplateParamData(param)
        }</span>

        <span class="cov0" title="0">return data</span>
}

func parseTemplateParamData(data bloblang.TemplateParamData) bloblang.TemplateParamData <span class="cov0" title="0">{
        data.Description = correctString(data.Description)
        return data
}</span>

func correctString(inp string) string <span class="cov0" title="0">{
        res := correctHeaders(inp)
        res = replaceAsciidocLinksWithMarkdown(res)
        return res
}</span>

func correctHeaders(inp string) string <span class="cov0" title="0">{
        for re, replacement := range replacements </span><span class="cov0" title="0">{
                inp = re.ReplaceAllString(inp, replacement)
        }</span>
        <span class="cov0" title="0">return inp</span>
}

var (
        asciidocLinkRegex          = regexp.MustCompile(`(https?://[^\[]+)\[([^\]]+)\]`)
        xrefLinkRegex              = regexp.MustCompile(`xref:([^\[]+)\[([^\]]+)\]`)
        angleBracketLinkRegex      = regexp.MustCompile(`&lt;&lt;([^,]+),([^&gt;]+)&gt;&gt;`)
        singlAngleBracketLinkRegex = regexp.MustCompile(`&lt;&lt;([^&gt;]+)&gt;&gt;`)
)

func replaceAsciidocLinksWithMarkdown(input string) string <span class="cov10" title="8">{
        input = asciidocLinkRegex.ReplaceAllStringFunc(input, func(match string) string </span><span class="cov7" title="5">{
                parts := asciidocLinkRegex.FindStringSubmatch(match)
                if len(parts) == 3 </span><span class="cov7" title="5">{
                        url := parts[1]
                        text := strings.TrimSuffix(parts[2], "^")
                        return "[" + text + "](" + url + ")"
                }</span>
                <span class="cov0" title="0">return match</span>
        })

        <span class="cov10" title="8">input = xrefLinkRegex.ReplaceAllStringFunc(input, func(match string) string </span><span class="cov4" title="2">{
                parts := xrefLinkRegex.FindStringSubmatch(match)
                if len(parts) == 3 </span><span class="cov4" title="2">{
                        //url := parts[1]
                        text := strings.TrimSuffix(parts[2], "^")
                        return text
                }</span>
                <span class="cov0" title="0">return match</span>
        })

        <span class="cov10" title="8">input = angleBracketLinkRegex.ReplaceAllStringFunc(input, func(match string) string </span><span class="cov1" title="1">{
                parts := angleBracketLinkRegex.FindStringSubmatch(match)
                if len(parts) == 3 </span><span class="cov1" title="1">{
                        //url := parts[1]
                        text := strings.TrimSuffix(parts[2], "^")
                        return text
                }</span>
                <span class="cov0" title="0">return match</span>
        })

        <span class="cov10" title="8">input = singlAngleBracketLinkRegex.ReplaceAllStringFunc(input, func(match string) string </span><span class="cov0" title="0">{
                parts := singlAngleBracketLinkRegex.FindStringSubmatch(match)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        //url := parts[1]
                        text := strings.TrimSuffix(parts[1], "^")
                        return text
                }</span>
                <span class="cov0" title="0">return match</span>
        })

        <span class="cov10" title="8">return input</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2024 Redpanda Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
        "bytes"
        "flag"
        "fmt"
        "os"
        "path"
        "path/filepath"
        "strings"
        "text/template"

        "github.com/redpanda-data/benthos/v4/public/bloblang"
        "github.com/redpanda-data/benthos/v4/public/service"

        _ "github.com/wombatwisdom/wombat/public/components/all"

        _ "embed"
)

var Version = "0.0.1"
var DateBuilt = "1970-01-01T00:00:00Z"

//go:embed templates/bloblang_functions.mdx.tmpl
var templateBloblFunctionsRaw string

//go:embed templates/bloblang_methods.mdx.tmpl
var templateBloblMethodsRaw string

//go:embed templates/plugin_fields.mdx.tmpl
var templatePluginFieldsRaw string

//go:embed templates/plugin.mdx.tmpl
var templatePluginRaw string

//go:embed templates/http.mdx.tmpl
var templateHTTPRaw string

//go:embed templates/logger.mdx.tmpl
var templateLoggerRaw string

//go:embed templates/tests.mdx.tmpl
var templateTestsRaw string

//go:embed templates/templates.mdx.tmpl
var templateTemplatesRaw string

var (
        templateBloblFunctions *template.Template
        templateBloblMethods   *template.Template
        templatePlugin         *template.Template
        templateHTTP           *template.Template
        templateLogger         *template.Template
        templateTests          *template.Template
        templateTemplates      *template.Template
)

func init() <span class="cov8" title="1">{
        templateBloblFunctions = template.Must(template.New("bloblang functions").Parse(templateBloblFunctionsRaw))
        templateBloblMethods = template.Must(template.New("bloblang methods").Parse(templateBloblMethodsRaw))
        templatePlugin = template.Must(template.New("plugin").Parse(templatePluginFieldsRaw + templatePluginRaw))
        templateHTTP = template.Must(template.New("http").Parse(templatePluginFieldsRaw + templateHTTPRaw))
        templateLogger = template.Must(template.New("logger").Parse(templatePluginFieldsRaw + templateLoggerRaw))
        templateTests = template.Must(template.New("tests").Parse(templatePluginFieldsRaw + templateTestsRaw))
        templateTemplates = template.Must(template.New("templates").Parse(templatePluginFieldsRaw + templateTemplatesRaw))
}</span>

func create(t, path string, resBytes []byte) <span class="cov0" title="0">{
        if existing, err := os.ReadFile(path); err == nil </span><span class="cov0" title="0">{
                if bytes.Equal(existing, resBytes) </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">if err := os.WriteFile(path, resBytes, 0o644); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Documentation for '%v' has changed, updating: %v\n", t, path)</span>
}

func getSchema() *service.ConfigSchema <span class="cov0" title="0">{
        env := service.GlobalEnvironment()
        s := env.FullConfigSchema(Version, DateBuilt)

        s.SetFieldDefault(map[string]any{
                "@service": "wombat",
        }, "logger", "static_fields")

        return s
}</span>

func main() <span class="cov0" title="0">{
        docsDir := "./website/src/content/docs"
        flag.StringVar(&amp;docsDir, "dir", docsDir, "The directory to write docs to")
        flag.Parse()

        env := getSchema().Environment()

        refDir := path.Join(docsDir, "./reference")

        env.WalkInputs(viewForDir(path.Join(refDir, "./components/inputs")))
        env.WalkBuffers(viewForDir(path.Join(refDir, "./components/buffers")))
        env.WalkCaches(viewForDir(path.Join(refDir, "./components/caches")))
        env.WalkMetrics(viewForDir(path.Join(refDir, "./components/metrics")))
        env.WalkOutputs(viewForDir(path.Join(refDir, "./components/outputs")))
        env.WalkProcessors(viewForDir(path.Join(refDir, "./components/processors")))
        env.WalkRateLimits(viewForDir(path.Join(refDir, "./components/rate_limits")))
        env.WalkTracers(viewForDir(path.Join(refDir, "./components/tracers")))
        env.WalkScanners(viewForDir(path.Join(refDir, "./components/scanners")))

        // Bloblang stuff
        doBloblangMethods(refDir)
        doBloblangFunctions(refDir)

        // Unit test docs
        doTestDocs(refDir)

        // HTTP docs
        doHTTP(refDir)

        // Logger docs
        doLogger(refDir)

        // Template docs
        doTemplates(refDir)
}</span>

func viewForDir(docsDir string) func(string, *service.ConfigView) <span class="cov0" title="0">{
        return func(name string, view *service.ConfigView) </span><span class="cov0" title="0">{
                data, err := view.TemplateData()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to prepare docs for '%v': %v", name, err))</span>
                }

                <span class="cov0" title="0">data = parsePluginTemplateData(data)

                var buf bytes.Buffer
                if err := templatePlugin.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to generate docs for '%v': %v", name, err))</span>
                }

                <span class="cov0" title="0">if err := os.MkdirAll(docsDir, 0755); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to create docs directory path '%v': %v", docsDir, err))</span>
                }

                <span class="cov0" title="0">create(name, path.Join(docsDir, name+".mdx"), buf.Bytes())</span>
        }
}

type functionCategory struct {
        Name  string
        Specs []bloblang.TemplateFunctionData
}

type functionsContext struct {
        Categories []functionCategory
}

func doBloblangFunctions(dir string) <span class="cov0" title="0">{
        var specs []bloblang.TemplateFunctionData
        bloblang.GlobalEnvironment().WalkFunctions(func(name string, spec *bloblang.FunctionView) </span><span class="cov0" title="0">{
                tmpl := spec.TemplateData()
                prefixExamples(tmpl.Examples)
                specs = append(specs, parseTemplateFunctionData(tmpl))
        }</span>)

        <span class="cov0" title="0">ctx := functionsContext{}
        for _, cat := range []string{
                "General",
                "Message Info",
                "Environment",
                "Fake Data Generation",
                "Deprecated",
        } </span><span class="cov0" title="0">{
                functions := functionCategory{
                        Name: cat,
                }
                for _, spec := range specs </span><span class="cov0" title="0">{
                        if spec.Category == cat </span><span class="cov0" title="0">{
                                functions.Specs = append(functions.Specs, spec)
                        }</span>
                }
                <span class="cov0" title="0">if len(functions.Specs) &gt; 0 </span><span class="cov0" title="0">{
                        ctx.Categories = append(ctx.Categories, functions)
                }</span>
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        if err := templateBloblFunctions.Execute(&amp;buf, ctx); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to generate docs for bloblang functions: %v", err))</span>
        }

        <span class="cov0" title="0">create("bloblang functions", filepath.Join(dir, "bloblang", "functions.mdx"), buf.Bytes())</span>
}

type methodCategory struct {
        Name  string
        Specs []bloblang.TemplateMethodData
}

type methodsContext struct {
        Categories []methodCategory
        General    []bloblang.TemplateMethodData
}

func prefixExamples(s []bloblang.TemplateExampleData) <span class="cov0" title="0">{
        for _, spec := range s </span><span class="cov0" title="0">{
                for i := range spec.Results </span><span class="cov0" title="0">{
                        spec.Results[i][0] = strings.ReplaceAll(
                                strings.TrimSuffix(spec.Results[i][0], "\n"),
                                "\n", "\n#      ",
                        )
                        spec.Results[i][1] = strings.ReplaceAll(
                                strings.TrimSuffix(spec.Results[i][1], "\n"),
                                "\n", "\n#      ",
                        )
                }</span>
        }
}

func methodForCat(s bloblang.TemplateMethodData, cat string) (bloblang.TemplateMethodData, bool) <span class="cov0" title="0">{
        for _, c := range s.Categories </span><span class="cov0" title="0">{
                if c.Category == cat </span><span class="cov0" title="0">{
                        spec := s
                        if c.Description != "" </span><span class="cov0" title="0">{
                                spec.Description = strings.TrimSpace(c.Description)
                        }</span>
                        <span class="cov0" title="0">if len(c.Examples) &gt; 0 </span><span class="cov0" title="0">{
                                spec.Examples = c.Examples
                        }</span>
                        <span class="cov0" title="0">return spec, true</span>
                }
        }
        <span class="cov0" title="0">return s, false</span>
}

func doBloblangMethods(dir string) <span class="cov0" title="0">{
        var specs []bloblang.TemplateMethodData
        bloblang.GlobalEnvironment().WalkMethods(func(name string, spec *bloblang.MethodView) </span><span class="cov0" title="0">{
                tmpl := spec.TemplateData()
                prefixExamples(tmpl.Examples)
                for _, cat := range tmpl.Categories </span><span class="cov0" title="0">{
                        prefixExamples(cat.Examples)
                }</span>
                <span class="cov0" title="0">specs = append(specs, parseTemplateMethodData(tmpl))</span>
        })

        <span class="cov0" title="0">ctx := methodsContext{}
        for _, cat := range []string{
                "String Manipulation",
                "Regular Expressions",
                "Number Manipulation",
                "Timestamp Manipulation",
                "Type Coercion",
                "Object &amp; Array Manipulation",
                "Parsing",
                "Encoding and Encryption",
                "SQL",
                "JSON Web Tokens",
                "GeoIP",
                "Deprecated",
        } </span><span class="cov0" title="0">{
                methods := methodCategory{
                        Name: cat,
                }
                for _, spec := range specs </span><span class="cov0" title="0">{
                        var ok bool
                        if spec, ok = methodForCat(spec, cat); ok </span><span class="cov0" title="0">{
                                methods.Specs = append(methods.Specs, spec)
                        }</span>
                }
                <span class="cov0" title="0">if len(methods.Specs) &gt; 0 </span><span class="cov0" title="0">{
                        ctx.Categories = append(ctx.Categories, methods)
                }</span>
        }

        <span class="cov0" title="0">for _, spec := range specs </span><span class="cov0" title="0">{
                if len(spec.Categories) == 0 &amp;&amp; spec.Status != "hidden" </span><span class="cov0" title="0">{
                        spec.Description = strings.TrimSpace(spec.Description)
                        ctx.General = append(ctx.General, spec)
                }</span>
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        err := templateBloblMethods.Execute(&amp;buf, ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to generate docs for bloblang methods: %v", err))</span>
        }

        <span class="cov0" title="0">create("bloblang methods", filepath.Join(dir, "bloblang", "methods.mdx"), buf.Bytes())</span>
}

func doTestDocs(dir string) <span class="cov0" title="0">{
        data, err := getSchema().TemplateData()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to prepare tests docs: %v", err))</span>
        }

        <span class="cov0" title="0">var newFields []service.TemplateDataPluginField
        for _, f := range data.Fields </span><span class="cov0" title="0">{
                if strings.HasPrefix(f.FullName, "tests") </span><span class="cov0" title="0">{
                        newFields = append(newFields, f)
                }</span>
        }
        <span class="cov0" title="0">data.Fields = newFields

        var buf bytes.Buffer
        if err := templateTests.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to generate tests docs: %v", err))</span>
        }

        <span class="cov0" title="0">create("tests docs", filepath.Join(dir, "configuration", "unit_testing.mdx"), buf.Bytes())</span>
}

func doHTTP(dir string) <span class="cov0" title="0">{
        data, err := getSchema().TemplateData("http")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to prepare http docs: %v", err))</span>
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        if err := templateHTTP.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to generate http docs: %v", err))</span>
        }

        <span class="cov0" title="0">create("http docs", filepath.Join(dir, "configuration", "http.mdx"), buf.Bytes())</span>
}

func doLogger(dir string) <span class="cov0" title="0">{
        data, err := getSchema().TemplateData("logger")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to prepare logger docs: %v", err))</span>
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        if err := templateLogger.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to generate logger docs: %v", err))</span>
        }

        <span class="cov0" title="0">create("logger docs", filepath.Join(dir, "configuration", "logger.mdx"), buf.Bytes())</span>
}

func doTemplates(dir string) <span class="cov0" title="0">{
        data, err := getSchema().Environment().TemplateSchema("", "").TemplateData()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to prepare template docs: %v", err))</span>
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        if err := templateTemplates.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to generate template docs: %v", err))</span>
        }

        <span class="cov0" title="0">create("tests docs", filepath.Join(dir, "configuration", "templating.mdx"), buf.Bytes())</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "github.com/redpanda-data/benthos/v4/public/service"
        _ "github.com/wombatwisdom/wombat/public/components/all"
)

var Version = "0.0.1"
var DateBuilt = "1970-01-01T00:00:00Z"

func main() <span class="cov0" title="0">{
        service.RunCLI(context.Background(),
                service.CLIOptSetProductName("Wombat"),
                service.CLIOptSetBinaryName("wombat"),
                service.CLIOptSetVersion(Version, DateBuilt),
                service.CLIOptSetDocumentationURL("https://wombat.dev"),
        )
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package docs

import (
        "github.com/redpanda-data/benthos/v4/public/bloblang"
        "github.com/redpanda-data/benthos/v4/public/service"
        "strings"
)

type PluginDocView struct {
        Kind        string `json:"kind"`
        Name        string `json:"name"`
        Summary     string `json:"summary,omitempty"`
        Description string `json:"description,omitempty"`
        Footnotes   string `json:"footnotes,omitempty"`
        Version     string `json:"version,omitempty"`
        Status      string `json:"status"`

        Categories []string  `json:"categories,omitempty"`
        Examples   []Example `json:"examples,omitempty"`

        // Fields are only available on components, not on bloblang methods or functions.
        Fields []Field `json:"fields,omitempty"`

        // Params on the other hand are only available on bloblang methods and functions.
        Params             []Param `json:"params,omitempty"`
        VariadicParameters bool    `json:"variadic_parameters,omitempty"`
}

type Param struct {
        Name         string `json:"name"`
        Description  string `json:"description,omitempty"`
        ValueType    string `json:"type"`
        IsOptional   bool   `json:"is_optional,omitempty"`
        DefaultValue string `json:"default,omitempty"`
}

type Field struct {
        // The description of the field.
        Description string `json:"description"`

        // Whether the field contains secrets.
        IsSecret bool `json:"isSecret"`

        // Whether the field is interpolated.
        IsInterpolated bool `json:"isInterpolated"`

        // The type information of the field.
        Type string `json:"type"`

        // The version in which this field was added.
        Version string `json:"version"`

        // An array of enum options accompanied by a description.
        AnnotatedOptions [][2]string `json:"annotatedOptions,omitempty"`

        // An array of enum options, without annotations.
        Options []string `json:"options,omitempty"`

        // An array of example values.
        Examples []any `json:"examples,omitempty"`

        // FullName describes the full dot path name of the field relative to
        // the root of the documented component.
        FullName string `json:"name"`

        // ExamplesMarshalled is a list of examples marshalled into YAML format.
        ExamplesMarshalled []string `json:"examplesMarshalled,omitempty"`

        // DefaultMarshalled is a marshalled string of the default value in JSON
        // format, if there is one.
        DefaultMarshalled string `json:"defaultMarshalled,omitempty"`
}

type Example struct {
        Summary string `json:"summary"`
        Content string `json:"content,omitempty"`

        // -- only filled in in case of a bloblang example
        Results [][2]string `json:"results,omitempty"`
}

func ParseDocViewFromConfigView(cv *service.ConfigView) (*PluginDocView, error) <span class="cov0" title="0">{
        td, err := cv.TemplateData()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var examples []Example
        for _, ted := range td.Examples </span><span class="cov0" title="0">{
                examples = append(examples, exampleFromTemplateExampleData(ted))
        }</span>

        <span class="cov0" title="0">var fields []Field
        for _, ted := range td.Fields </span><span class="cov0" title="0">{
                fields = append(fields, fieldFromTemplateData(ted))
        }</span>

        <span class="cov0" title="0">return &amp;PluginDocView{
                Kind:        td.Type,
                Name:        td.Name,
                Summary:     td.Summary,
                Description: sanitizeMarkdown(td.Description),
                Footnotes:   td.Footnotes,
                Version:     td.Version,
                Status:      td.Status,
                Categories:  strings.Split(td.Categories, ","),
                Examples:    examples,
                Fields:      fields,
        }, nil</span>
}

func ParseDocViewFromMethodView(mv *bloblang.MethodView) (*PluginDocView, error) <span class="cov0" title="0">{
        td := mv.TemplateData()

        var categories []string
        for _, cat := range td.Categories </span><span class="cov0" title="0">{
                categories = append(categories, cat.Category)
        }</span>

        <span class="cov0" title="0">var examples []Example
        for _, ted := range td.Examples </span><span class="cov0" title="0">{
                examples = append(examples, exampleFromBloblangTemplateData(ted))
        }</span>

        <span class="cov0" title="0">var params []Param
        for _, p := range td.Params.Definitions </span><span class="cov0" title="0">{
                params = append(params, Param{
                        Name:         p.Name,
                        Description:  p.Description,
                        ValueType:    p.ValueType,
                        IsOptional:   p.IsOptional,
                        DefaultValue: p.DefaultMarshalled,
                })
        }</span>

        <span class="cov0" title="0">return &amp;PluginDocView{
                Kind:               "method",
                Name:               td.Name,
                Description:        td.Description,
                Version:            td.Version,
                Status:             td.Status,
                Categories:         categories,
                Examples:           examples,
                Params:             params,
                VariadicParameters: false,
        }, nil</span>
}

func ParseDocViewFromFunctionView(fv *bloblang.FunctionView) (*PluginDocView, error) <span class="cov0" title="0">{
        td := fv.TemplateData()

        var examples []Example
        for _, ted := range td.Examples </span><span class="cov0" title="0">{
                examples = append(examples, exampleFromBloblangTemplateData(ted))
        }</span>

        <span class="cov0" title="0">var params []Param
        for _, p := range td.Params.Definitions </span><span class="cov0" title="0">{
                params = append(params, Param{
                        Name:         p.Name,
                        Description:  sanitizeMarkdown(p.Description),
                        ValueType:    p.ValueType,
                        IsOptional:   p.IsOptional,
                        DefaultValue: p.DefaultMarshalled,
                })
        }</span>

        <span class="cov0" title="0">return &amp;PluginDocView{
                Kind:               "function",
                Name:               td.Name,
                Description:        sanitizeMarkdown(td.Description),
                Version:            td.Version,
                Status:             td.Status,
                Categories:         []string{td.Category},
                Examples:           examples,
                Params:             params,
                VariadicParameters: false,
        }, nil</span>
}

func exampleFromTemplateExampleData(ted service.TemplatDataPluginExample) Example <span class="cov0" title="0">{
        return Example{
                Summary: ted.Summary,
                Content: ted.Config,
        }
}</span>

func exampleFromBloblangTemplateData(ted bloblang.TemplateExampleData) Example <span class="cov0" title="0">{
        return Example{
                Summary: ted.Summary,
                Content: ted.Mapping,
                Results: ted.Results,
        }
}</span>

func fieldFromTemplateData(ted service.TemplateDataPluginField) Field <span class="cov0" title="0">{
        return Field{
                Description:        ted.Description,
                IsSecret:           ted.IsSecret,
                IsInterpolated:     ted.IsInterpolated,
                Type:               ted.Type,
                Version:            ted.Version,
                AnnotatedOptions:   ted.AnnotatedOptions,
                Options:            ted.Options,
                Examples:           ted.Examples,
                FullName:           ted.FullName,
                ExamplesMarshalled: ted.ExamplesMarshalled,
                DefaultMarshalled:  ted.DefaultMarshalled,
        }
}</span>

func sanitizeMarkdown(input string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(input, "\n== ", "\n## ")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package docs

import (
        "github.com/redpanda-data/benthos/v4/public/bloblang"
        "github.com/redpanda-data/benthos/v4/public/service"
        "github.com/sirupsen/logrus"
)

type Kind string

const (
        KindInput     Kind = "input"
        KindOutput    Kind = "output"
        KindCache     Kind = "cache"
        KindBuffer    Kind = "buffer"
        KindProcessor Kind = "processor"
        KindRateLimit Kind = "rate_limit"
        KindTracer    Kind = "tracer"
        KindScanner   Kind = "scanner"
        KindMetric    Kind = "metric"

        KindFunction Kind = "function"
        KindMethod   Kind = "method"
)

type Snapshot struct {
        Inputs     map[string]struct{}
        Outputs    map[string]struct{}
        Caches     map[string]struct{}
        Buffers    map[string]struct{}
        Processors map[string]struct{}
        RateLimits map[string]struct{}
        Tracers    map[string]struct{}
        Scanners   map[string]struct{}
        Metrics    map[string]struct{}

        Functions map[string]struct{}
        Methods   map[string]struct{}
}

func GlobalScanner() *Scanner <span class="cov0" title="0">{
        return &amp;Scanner{
                benv: bloblang.GlobalEnvironment(),
                env:  service.GlobalEnvironment(),
        }
}</span>

type Scanner struct {
        benv *bloblang.Environment
        env  *service.Environment
}

func (s *Scanner) Scan(fn func(doc *PluginDocView)) <span class="cov0" title="0">{
        s.benv.WalkFunctions(functionWalker(fn))
        s.benv.WalkMethods(methodWalker(fn))

        s.env.WalkBuffers(walker(fn))
        s.env.WalkCaches(walker(fn))
        s.env.WalkInputs(walker(fn))
        s.env.WalkOutputs(walker(fn))
        s.env.WalkProcessors(walker(fn))
        s.env.WalkRateLimits(walker(fn))
        s.env.WalkTracers(walker(fn))
        s.env.WalkScanners(walker(fn))
        s.env.WalkMetrics(walker(fn))
}</span>

func (s *Scanner) ConfigSchema() *service.ConfigSchema <span class="cov0" title="0">{
        return s.env.FullConfigSchema("", "")
}</span>

func methodWalker(fn func(doc *PluginDocView)) func(name string, spec *bloblang.MethodView) <span class="cov0" title="0">{
        return func(name string, spec *bloblang.MethodView) </span><span class="cov0" title="0">{
                dv, err := ParseDocViewFromMethodView(spec)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Failed to parse method %s: %v", name, err)
                        return
                }</span>

                <span class="cov0" title="0">fn(dv)</span>
        }
}

func functionWalker(fn func(doc *PluginDocView)) func(name string, spec *bloblang.FunctionView) <span class="cov0" title="0">{
        return func(name string, spec *bloblang.FunctionView) </span><span class="cov0" title="0">{
                dv, err := ParseDocViewFromFunctionView(spec)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Failed to parse function %s: %v", name, err)
                        return
                }</span>

                <span class="cov0" title="0">fn(dv)</span>
        }
}

func walker(fn func(doc *PluginDocView)) func(name string, config *service.ConfigView) <span class="cov0" title="0">{
        return func(name string, config *service.ConfigView) </span><span class="cov0" title="0">{
                dv, err := ParseDocViewFromConfigView(config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Failed to parse component %s: %v", name, err)
                        return
                }</span>

                <span class="cov0" title="0">fn(dv)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package snowflake

import (
        "bytes"
        "context"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "database/sql"
        "encoding/base64"
        "encoding/json"
        "encoding/pem"
        "errors"
        "fmt"
        "github.com/redpanda-data/benthos/v4/public/service"
        "io/fs"
        "net/http"
        "net/url"
        "path"
        "strings"
        "sync"
        "time"

        "github.com/gofrs/uuid"
        "github.com/golang-jwt/jwt/v5"
        "github.com/snowflakedb/gosnowflake"
        "github.com/youmark/pkcs8"
        "golang.org/x/crypto/ssh"
)

const (
        defaultJWTTimeout = 60 * time.Second
)

// CompressionType represents the compression used for the payloads sent to Snowflake.
type CompressionType string

const (
        // CompressionTypeNone No compression.
        CompressionTypeNone CompressionType = "NONE"
        // CompressionTypeAuto Automatic compression (gzip).
        CompressionTypeAuto CompressionType = "AUTO"
        // CompressionTypeGzip Gzip compression.
        CompressionTypeGzip CompressionType = "GZIP"
        // CompressionTypeDeflate Deflate compression using zlib algorithm (with zlib header, RFC1950).
        CompressionTypeDeflate CompressionType = "DEFLATE"
        // CompressionTypeRawDeflate Deflate compression using flate algorithm (without header, RFC1951).
        CompressionTypeRawDeflate CompressionType = "RAW_DEFLATE"
        // CompressionTypeZstandard compression using Zstandard algorithm.
        CompressionTypeZstandard CompressionType = "ZSTD"
)

func snowflakePutOutputConfig() *service.ConfigSpec <span class="cov8" title="1">{
        return service.NewConfigSpec().
                Beta().
                Categories("Services").
                Version("1.0.0").
                Summary("Sends messages to Snowflake stages and, optionally, calls Snowpipe to load this data into one or more tables.").
                Description(`
In order to use a different stage and / or Snowpipe for each message, you can use function interpolations as described
[here](/docs/configuration/interpolation#bloblang-queries). When using batching, messages are grouped by the calculated
stage and Snowpipe and are streamed to individual files in their corresponding stage and, optionally, a Snowpipe
`+"`insertFiles`"+` REST API call will be made for each individual file.

### Credentials

Two authentication mechanisms are supported:
- User/password
- Key Pair Authentication

#### User/password

This is a basic authentication mechanism which allows you to PUT data into a stage. However, it is not compatible with
Snowpipe.

#### Key Pair Authentication

This authentication mechanism allows Snowpipe functionality, but it does require configuring an SSH Private Key
beforehand. Please consult the [documentation](https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication)
for details on how to set it up and assign the Public Key to your user.

Note that the Snowflake documentation [used to suggest](https://twitter.com/felipehoffa/status/1560811785606684672)
using this command:

`+"```shell"+`
openssl genrsa 2048 | openssl pkcs8 -topk8 -inform PEM -out rsa_key.p8
`+"```"+`

to generate an encrypted SSH private key. However, in this case, it uses an encryption algorithm called
`+"`pbeWithMD5AndDES-CBC`"+`, which is part of the PKCS#5 v1.5 and is considered insecure. Due to this, Bento does not
support it and, if you wish to use password-protected keys directly, you must use PKCS#5 v2.0 to encrypt them by using
the following command (as the current Snowflake docs suggest):

`+"```shell"+`
openssl genrsa 2048 | openssl pkcs8 -topk8 -v2 des3 -inform PEM -out rsa_key.p8
`+"```"+`

If you have an existing key encrypted with PKCS#5 v1.5, you can re-encrypt it with PKCS#5 v2.0 using this command:

`+"```shell"+`
openssl pkcs8 -in rsa_key_original.p8 -topk8 -v2 des3 -out rsa_key.p8
`+"```"+`

Please consult [this](https://linux.die.net/man/1/pkcs8) pkcs8 command documentation for details on PKCS#5 algorithms.

### Batching

It's common to want to upload messages to Snowflake as batched archives. The easiest way to do this is to batch your
messages at the output level and join the batch of messages with an
`+"[`archive`](/docs/components/processors/archive)"+` and/or `+"[`compress`](/docs/components/processors/compress)"+`
processor.

For the optimal batch size, please consult the Snowflake [documentation](https://docs.snowflake.com/en/user-guide/data-load-considerations-prepare.html).

### Snowpipe

Given a table called `+"`WOMBAT_TBL`"+` with one column of type `+"`variant`"+`:

`+"```sql"+`
CREATE OR REPLACE TABLE WOMBAT_DB.PUBLIC.WOMBAT_TBL(RECORD variant)
`+"```"+`

and the following `+"`WOMBAT_PIPE`"+` Snowpipe:

`+"```sql"+`
CREATE OR REPLACE PIPE WOMBAT_DB.PUBLIC.WOMBAT_PIPE AUTO_INGEST = FALSE AS COPY INTO WOMBAT_DB.PUBLIC.WOMBAT_TBL FROM (SELECT * FROM @%WOMBAT_TBL) FILE_FORMAT = (TYPE = JSON COMPRESSION = AUTO)
`+"```"+`

you can configure Bento to use the implicit table stage `+"`@%WOMBAT_TBL`"+` as the `+"`stage`"+` and
`+"`WOMBAT_PIPE`"+` as the `+"`snowpipe`"+`. In this case, you must set `+"`compression`"+` to `+"`AUTO`"+` and, if
using message batching, you'll need to configure an [`+"`archive`"+`](/docs/components/processors/archive) processor
with the `+"`concatenate`"+` format. Since the `+"`compression`"+` is set to `+"`AUTO`"+`, the
[gosnowflake](https://github.com/snowflakedb/gosnowflake) client library will compress the messages automatically so you
don't need to add a `+"[`compress`](/docs/components/processors/compress)"+` processor for message batches.

If you add `+"`STRIP_OUTER_ARRAY = TRUE`"+` in your Snowpipe `+"`FILE_FORMAT`"+`
definition, then you must use `+"`json_array`"+` instead of `+"`concatenate`"+` as the archive processor format.

Note: Only Snowpipes with `+"`FILE_FORMAT`"+` `+"`TYPE`"+` `+"`JSON`"+` are currently supported.

### Snowpipe Troubleshooting

Snowpipe [provides](https://docs.snowflake.com/en/user-guide/data-load-snowpipe-rest-apis.html) the `+"`insertReport`"+`
and `+"`loadHistoryScan`"+` REST API endpoints which can be used to get information about recent Snowpipe calls. In
order to query them, you'll first need to generate a valid JWT token for your Snowflake account. There are two methods
for doing so:
- Using the `+"`snowsql`"+` [utility](https://docs.snowflake.com/en/user-guide/snowsql.html):

`+"```shell"+`
snowsql --private-key-path rsa_key.p8 --generate-jwt -a &lt;account&gt; -u &lt;user&gt;
`+"```"+`

- Using the Python `+"`sql-api-generate-jwt`"+` [utility](https://docs.snowflake.com/en/developer-guide/sql-api/authenticating.html#generating-a-jwt-in-python):

`+"```shell"+`
python3 sql-api-generate-jwt.py --private_key_file_path=rsa_key.p8 --account=&lt;account&gt; --user=&lt;user&gt;
`+"```"+`

Once you successfully generate a JWT token and store it into the `+"`JWT_TOKEN`"+` environment variable, then you can,
for example, query the `+"`insertReport`"+` endpoint using `+"`curl`"+`:

`+"```shell"+`
curl -H "Authorization: Bearer ${JWT_TOKEN}" "https://&lt;account&gt;.snowflakecomputing.com/v1/data/pipes/&lt;database&gt;.&lt;schema&gt;.&lt;snowpipe&gt;/insertReport"
`+"```"+`

If you need to pass in a valid `+"`requestId`"+` to any of these Snowpipe REST API endpoints, you can set a
[uuid_v4()](/bloblang/functions#uuid_v4) string in a metadata field called
`+"`request_id`"+`, log it via the [`+"`log`"+`](/reference/components/processors/log) processor and
then configure `+"`request_id: ${ @request_id }`"+` ). Alternatively, you can enable debug logging as described
[here](/reference/configuration/logger) and Bento will print the Request IDs that it sends to Snowpipe.

### General Troubleshooting

The underlying [`+"`gosnowflake`"+` driver](https://github.com/snowflakedb/gosnowflake) requires write access to
the default directory to use for temporary files. Please consult the [`+"`os.TempDir`"+`](https://pkg.go.dev/os#TempDir)
docs for details on how to change this directory via environment variables.

A silent failure can occur due to [this issue](https://github.com/snowflakedb/gosnowflake/issues/701), where the
underlying [`+"`gosnowflake`"+` driver](https://github.com/snowflakedb/gosnowflake) doesn't return an error and doesn't
log a failure if it can't figure out the current username. One way to trigger this behaviour is by running Bento in a
Docker container with a non-existent user ID (such as `+"`--user 1000:1000`"+`).
`+service.OutputPerformanceDocs(true, true)).
                Field(service.NewStringField("account").Description(`Account name, which is the same as the Account Identifier
as described [here](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#where-are-account-identifiers-used).
However, when using an [Account Locator](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier),
the Account Identifier is formatted as `+"`&lt;account_locator&gt;.&lt;region_id&gt;.&lt;cloud&gt;`"+` and this field needs to be
populated using the `+"`&lt;account_locator&gt;`"+` part.
`)).
                Field(service.NewStringField("region").Description(`Optional region field which needs to be populated when using
an [Account Locator](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier)
and it must be set to the `+"`&lt;region_id&gt;`"+` part of the Account Identifier
(`+"`&lt;account_locator&gt;.&lt;region_id&gt;.&lt;cloud&gt;`"+`).
`).Example("us-west-2").Optional()).
                Field(service.NewStringField("cloud").Description(`Optional cloud platform field which needs to be populated
when using an [Account Locator](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier)
and it must be set to the `+"`&lt;cloud&gt;`"+` part of the Account Identifier
(`+"`&lt;account_locator&gt;.&lt;region_id&gt;.&lt;cloud&gt;`"+`).
`).Example("aws").Example("gcp").Example("azure").Optional()).
                Field(service.NewStringField("user").Description("Username.")).
                Field(service.NewStringField("password").Description("An optional password.").Optional().Secret()).
                Field(service.NewStringField("private_key_file").Description("The path to a file containing the private SSH key.").Optional()).
                Field(service.NewStringField("private_key_pass").Description("An optional private SSH key passphrase.").Optional().Secret()).
                Field(service.NewStringField("role").Description("Role.")).
                Field(service.NewStringField("database").Description("Database.")).
                Field(service.NewStringField("warehouse").Description("Warehouse.")).
                Field(service.NewStringField("schema").Description("Schema.")).
                Field(service.NewInterpolatedStringField("stage").Description(`Stage name. Use either one of the
[supported](https://docs.snowflake.com/en/user-guide/data-load-local-file-system-create-stage.html) stage types.`)).
                Field(service.NewInterpolatedStringField("path").Description("Stage path.").Default("")).
                Field(service.NewInterpolatedStringField("file_name").Description("Stage file name. Will be equal to the Request ID if not set or empty.").Optional().Default("").Version("v4.12.0")).
                Field(service.NewInterpolatedStringField("file_extension").Description("Stage file extension. Will be derived from the configured `compression` if not set or empty.").Optional().Default("").Example("csv").Example("parquet").Version("v4.12.0")).
                Field(service.NewIntField("upload_parallel_threads").Description("Specifies the number of threads to use for uploading files.").Advanced().Default(4).LintRule(`root = if this &lt; 1 || this &gt; 99 { [ "upload_parallel_threads must be between 1 and 99" ] }`)).
                Field(service.NewStringAnnotatedEnumField("compression", map[string]string{
                        string(CompressionTypeNone):       "No compression is applied and messages must contain plain-text JSON. Default `file_extension`: `json`.",
                        string(CompressionTypeAuto):       "Compression (gzip) is applied automatically by the output and messages must contain plain-text JSON. Default `file_extension`: `gz`.",
                        string(CompressionTypeGzip):       "Messages must be pre-compressed using the gzip algorithm. Default `file_extension`: `gz`.",
                        string(CompressionTypeDeflate):    "Messages must be pre-compressed using the zlib algorithm (with zlib header, RFC1950). Default `file_extension`: `deflate`.",
                        string(CompressionTypeRawDeflate): "Messages must be pre-compressed using the flate algorithm (without header, RFC1951). Default `file_extension`: `raw_deflate`.",
                        string(CompressionTypeZstandard):  "Messages must be pre-compressed using the Zstandard algorithm. Default `file_extension`: `zst`.",
                }).Description("Compression type.").Default(string(CompressionTypeAuto))).
                Field(service.NewInterpolatedStringField("request_id").Description("Request ID. Will be assigned a random UUID (v4) string if not set or empty.").Optional().Default("").Version("v4.12.0")).
                Field(service.NewInterpolatedStringField("snowpipe").Description(`An optional Snowpipe name. Use the `+"`&lt;snowpipe&gt;`"+` part from `+"`&lt;database&gt;.&lt;schema&gt;.&lt;snowpipe&gt;`"+`.`).Optional()).
                Field(service.NewBoolField("client_session_keep_alive").Description("Enable Snowflake keepalive mechanism to prevent the client session from expiring after 4 hours (error 390114).").Advanced().Default(false)).
                Field(service.NewBatchPolicyField("batching")).
                Field(service.NewIntField("max_in_flight").Description("The maximum number of parallel message batches to have in flight at any given time.").Default(1)).
                LintRule(`root = match {
  this.exists("password") &amp;&amp; this.password != "" &amp;&amp; this.exists("private_key_file") &amp;&amp; this.private_key_file != "" =&gt; [ "both `+"`password`"+` and `+"`private_key_file`"+` can't be set simultaneously" ],
  this.exists("snowpipe") &amp;&amp; this.snowpipe != "" &amp;&amp; (!this.exists("private_key_file") || this.private_key_file == "") =&gt; [ "`+"`private_key_file`"+` is required when setting `+"`snowpipe`"+`" ],
}`).
                Example("Kafka / realtime brokers", "Upload message batches from realtime brokers such as Kafka persisting the batch partition and offsets in the stage path and filename similarly to the [Kafka Connector scheme](https://docs.snowflake.com/en/user-guide/kafka-connector-ts.html#step-1-view-the-copy-history-for-the-table) and call Snowpipe to load them into a table. When batching is configured at the input level, it is done per-partition.", `
input:
  kafka:
    addresses:
      - localhost:9092
    topics:
      - foo
    consumer_group: wombat
    batching:
      count: 10
      period: 3s
      processors:
        - mapping: |
            meta kafka_start_offset = meta("kafka_offset").from(0)
            meta kafka_end_offset = meta("kafka_offset").from(-1)
            meta batch_timestamp = if batch_index() == 0 { now() }
        - mapping: |
            meta batch_timestamp = if batch_index() != 0 { meta("batch_timestamp").from(0) }

output:
  snowflake_put:
    account: wombat
    user: test@wombat.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: WOMBAT_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    stage: "@%WOMBAT_TBL"
    path: wombat/WOMBAT_TBL/${! @kafka_partition }
    file_name: ${! @kafka_start_offset }_${! @kafka_end_offset }_${! meta("batch_timestamp") }
    upload_parallel_threads: 4
    compression: NONE
    snowpipe: WOMBAT_PIPE
`).
                Example("No compression", "Upload concatenated messages into a `.json` file to a table stage without calling Snowpipe.", `
output:
  snowflake_put:
    account: wombat
    user: test@wombat.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: WOMBAT_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    stage: "@%WOMBAT_TBL"
    path: wombat
    upload_parallel_threads: 4
    compression: NONE
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
`).
                Example("Parquet format with snappy compression", "Upload concatenated messages into a `.parquet` file to a table stage without calling Snowpipe.", `
output:
  snowflake_put:
    account: wombat
    user: test@wombat.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: WOMBAT_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    stage: "@%WOMBAT_TBL"
    path: wombat
    file_extension: parquet
    upload_parallel_threads: 4
    compression: NONE
    batching:
      count: 10
      period: 3s
      processors:
        - parquet_encode:
            schema:
              - name: ID
                type: INT64
              - name: CONTENT
                type: BYTE_ARRAY
            default_compression: snappy
`).
                Example("Automatic compression", "Upload concatenated messages compressed automatically into a `.gz` archive file to a table stage without calling Snowpipe.", `
output:
  snowflake_put:
    account: wombat
    user: test@wombat.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: WOMBAT_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    stage: "@%WOMBAT_TBL"
    path: wombat
    upload_parallel_threads: 4
    compression: AUTO
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
`).
                Example("DEFLATE compression", "Upload concatenated messages compressed into a `.deflate` archive file to a table stage and call Snowpipe to load them into a table.", `
output:
  snowflake_put:
    account: wombat
    user: test@wombat.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: WOMBAT_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    stage: "@%WOMBAT_TBL"
    path: wombat
    upload_parallel_threads: 4
    compression: DEFLATE
    snowpipe: WOMBAT_PIPE
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
        - mapping: |
            root = content().compress("zlib")
`).
                Example("RAW_DEFLATE compression", "Upload concatenated messages compressed into a `.raw_deflate` archive file to a table stage and call Snowpipe to load them into a table.", `
output:
  snowflake_put:
    account: wombat
    user: test@wombat.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: WOMBAT_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    stage: "@%WOMBAT_TBL"
    path: wombat
    upload_parallel_threads: 4
    compression: RAW_DEFLATE
    snowpipe: WOMBAT_PIPE
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
        - mapping: |
            root = content().compress("flate")
`)
}</span>

func init() <span class="cov8" title="1">{
        err := service.RegisterBatchOutput("snowflake_put", snowflakePutOutputConfig(),
                func(conf *service.ParsedConfig, mgr *service.Resources) (
                        output service.BatchOutput,
                        batchPolicy service.BatchPolicy,
                        maxInFlight int,
                        err error,
                ) </span><span class="cov0" title="0">{
                        if maxInFlight, err = conf.FieldInt("max_in_flight"); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if batchPolicy, err = conf.FieldBatchPolicy("batching"); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">output, err = newSnowflakeWriterFromConfig(conf, mgr)
                        return</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

//------------------------------------------------------------------------------

// getPrivateKey reads and parses the private key
// Inspired from https://github.com/chanzuckerberg/terraform-provider-snowflake/blob/c07d5820bea7ac3d8a5037b0486c405fdf58420e/pkg/provider/provider.go#L367
func getPrivateKey(f fs.FS, path, passphrase string) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        privateKeyBytes, err := service.ReadFile(f, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read private key %s: %s", path, err)
        }</span>
        <span class="cov0" title="0">if len(privateKeyBytes) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("private key is empty")
        }</span>

        <span class="cov0" title="0">privateKeyBlock, _ := pem.Decode(privateKeyBytes)
        if privateKeyBlock == nil </span><span class="cov0" title="0">{
                return nil, errors.New("could not parse private key, key is not in PEM format")
        }</span>

        <span class="cov0" title="0">if privateKeyBlock.Type == "ENCRYPTED PRIVATE KEY" </span><span class="cov0" title="0">{
                if passphrase == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("private key requires a passphrase, but private_key_passphrase was not supplied")
                }</span>

                // Only keys encrypted with pbes2 http://oid-info.com/get/1.2.840.113549.1.5.13 are supported.
                // pbeWithMD5AndDES-CBC http://oid-info.com/get/1.2.840.113549.1.5.3 is not supported.
                <span class="cov0" title="0">privateKey, err := pkcs8.ParsePKCS8PrivateKeyRSA(privateKeyBlock.Bytes, []byte(passphrase))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decrypt encrypted private key (only ciphers aes-128-cbc, aes-128-gcm, aes-192-cbc, aes-192-gcm, aes-256-cbc, aes-256-gcm, and des-ede3-cbc are supported): %s", err)
                }</span>

                <span class="cov0" title="0">return privateKey, nil</span>
        }

        <span class="cov0" title="0">privateKey, err := ssh.ParseRawPrivateKey(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not parse private key: %s", err)
        }</span>

        <span class="cov0" title="0">rsaPrivateKey, ok := privateKey.(*rsa.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key must be of type RSA but got %T instead: ", privateKey)
        }</span>
        <span class="cov0" title="0">return rsaPrivateKey, nil</span>
}

// calculatePublicKeyFingerprint computes the value of the `RSA_PUBLIC_KEY_FP` for the current user based on the
// configured private key
// Inspired from https://stackoverflow.com/questions/63598044/snowpipe-rest-api-returning-always-invalid-jwt-token
func calculatePublicKeyFingerprint(privateKey *rsa.PrivateKey) (string, error) <span class="cov0" title="0">{
        pubKey := privateKey.Public()
        pubDER, err := x509.MarshalPKIXPublicKey(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal public key: %s", err)
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256(pubDER)
        return "SHA256:" + base64.StdEncoding.EncodeToString(hash[:]), nil</span>
}

type dbI interface {
        ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
        Close() error
}

type uuidGenI interface {
        NewV4() (uuid.UUID, error)
}

type httpClientI interface {
        Do(req *http.Request) (*http.Response, error)
}

type snowflakeWriter struct {
        logger *service.Logger

        account       string
        user          string
        database      string
        schema        string
        stage         *service.InterpolatedString
        path          *service.InterpolatedString
        fileName      *service.InterpolatedString
        fileExtension *service.InterpolatedString
        requestID     *service.InterpolatedString
        snowpipe      *service.InterpolatedString

        accountIdentifier         string
        putQueryFormat            string
        defaultStageFileExtension string
        privateKey                *rsa.PrivateKey
        publicKeyFingerprint      string
        dsn                       string

        connMut       sync.Mutex
        uuidGenerator uuidGenI
        httpClient    httpClientI
        nowFn         func() time.Time
        db            dbI
}

func newSnowflakeWriterFromConfig(conf *service.ParsedConfig, mgr *service.Resources) (*snowflakeWriter, error) <span class="cov0" title="0">{
        s := snowflakeWriter{
                logger:        mgr.Logger(),
                uuidGenerator: uuid.NewGen(),
                httpClient:    http.DefaultClient,
                nowFn:         time.Now,
        }

        var err error

        if s.account, err = conf.FieldString("account"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse account: %s", err)
        }</span>

        <span class="cov0" title="0">s.accountIdentifier = s.account

        if conf.Contains("region") </span><span class="cov0" title="0">{
                var region string
                if region, err = conf.FieldString("region"); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse region: %s", err)
                }</span>
                <span class="cov0" title="0">s.accountIdentifier += "." + region</span>
        }

        <span class="cov0" title="0">if conf.Contains("cloud") </span><span class="cov0" title="0">{
                var cloud string
                if cloud, err = conf.FieldString("cloud"); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse cloud: %s", err)
                }</span>
                <span class="cov0" title="0">s.accountIdentifier += "." + cloud</span>
        }

        <span class="cov0" title="0">if s.user, err = conf.FieldString("user"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse user: %s", err)
        }</span>

        <span class="cov0" title="0">var password string
        if conf.Contains("password") </span><span class="cov0" title="0">{
                if password, err = conf.FieldString("password"); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse password: %s", err)
                }</span>
        }

        <span class="cov0" title="0">var role string
        if role, err = conf.FieldString("role"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse role: %s", err)
        }</span>

        <span class="cov0" title="0">if s.database, err = conf.FieldString("database"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse database: %s", err)
        }</span>

        <span class="cov0" title="0">var warehouse string
        if warehouse, err = conf.FieldString("warehouse"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse warehouse: %s", err)
        }</span>

        <span class="cov0" title="0">if s.schema, err = conf.FieldString("schema"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse schema: %s", err)
        }</span>

        <span class="cov0" title="0">if s.stage, err = conf.FieldInterpolatedString("stage"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse stage: %s", err)
        }</span>

        <span class="cov0" title="0">if s.path, err = conf.FieldInterpolatedString("path"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse path: %s", err)
        }</span>

        <span class="cov0" title="0">if s.fileName, err = conf.FieldInterpolatedString("file_name"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse file_name: %s", err)
        }</span>

        <span class="cov0" title="0">if s.fileExtension, err = conf.FieldInterpolatedString("file_extension"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse file_extension: %s", err)
        }</span>

        <span class="cov0" title="0">var uploadParallelThreads int
        if uploadParallelThreads, err = conf.FieldInt("upload_parallel_threads"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse stage: %s", err)
        }</span>

        <span class="cov0" title="0">compressionStr, err := conf.FieldString("compression")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse compression: %s", err)
        }</span>

        <span class="cov0" title="0">compression := CompressionType(compressionStr)
        var autoCompress, sourceCompression string
        // Should match file extensions in https://github.com/snowflakedb/gosnowflake/blob/2648a83699492c0613a888e66298157fc1e45bf5/file_compression_type.go
        switch compression </span>{
        case CompressionTypeNone:<span class="cov0" title="0">
                s.defaultStageFileExtension = "json"
                autoCompress = "FALSE"
                sourceCompression = "NONE"</span>
        case CompressionTypeAuto:<span class="cov0" title="0">
                s.defaultStageFileExtension = "gz"
                autoCompress = "TRUE"
                sourceCompression = "AUTO_DETECT"</span>
        case CompressionTypeGzip:<span class="cov0" title="0">
                s.defaultStageFileExtension = "gz"
                autoCompress = "FALSE"
                sourceCompression = "GZIP"</span>
        case CompressionTypeDeflate:<span class="cov0" title="0">
                s.defaultStageFileExtension = "deflate"
                autoCompress = "FALSE"
                sourceCompression = string(compression)</span>
        case CompressionTypeRawDeflate:<span class="cov0" title="0">
                s.defaultStageFileExtension = "raw_deflate"
                autoCompress = "FALSE"
                sourceCompression = string(compression)</span>
        case CompressionTypeZstandard:<span class="cov0" title="0">
                s.defaultStageFileExtension = "zst"
                autoCompress = "FALSE"
                sourceCompression = string(compression)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unrecognised compression type: %s", compression)</span>
        }

        // File path and stage are populated dynamically via interpolation
        <span class="cov0" title="0">s.putQueryFormat = fmt.Sprintf("PUT file://%%s %%s AUTO_COMPRESS = %s SOURCE_COMPRESSION = %s PARALLEL=%d", autoCompress, sourceCompression, uploadParallelThreads)

        if s.requestID, err = conf.FieldInterpolatedString("request_id"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse request_id: %s", err)
        }</span>

        <span class="cov0" title="0">if conf.Contains("snowpipe") </span><span class="cov0" title="0">{
                if s.snowpipe, err = conf.FieldInterpolatedString("snowpipe"); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse snowpipe: %s", err)
                }</span>
        }

        <span class="cov0" title="0">authenticator := gosnowflake.AuthTypeJwt
        if password == "" </span><span class="cov0" title="0">{
                var privateKeyFile string
                if privateKeyFile, err = conf.FieldString("private_key_file"); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse private_key_file: %s", err)
                }</span>

                <span class="cov0" title="0">var privateKeyPass string
                if conf.Contains("private_key_pass") </span><span class="cov0" title="0">{
                        if privateKeyPass, err = conf.FieldString("private_key_pass"); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse private_key_pass: %s", err)
                        }</span>
                }

                <span class="cov0" title="0">if s.privateKey, err = getPrivateKey(mgr.FS(), privateKeyFile, privateKeyPass); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read private key: %s", err)
                }</span>

                <span class="cov0" title="0">if s.publicKeyFingerprint, err = calculatePublicKeyFingerprint(s.privateKey); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to calculate public key fingerprint: %s", err)
                }</span>
        } else<span class="cov0" title="0"> {
                authenticator = gosnowflake.AuthTypeSnowflake
        }</span>

        <span class="cov0" title="0">var params map[string]*string
        if clientSessionKeepAlive, err := conf.FieldBool("client_session_keep_alive"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse client_session_keep_alive: %s", err)
        }</span> else<span class="cov0" title="0"> if clientSessionKeepAlive </span><span class="cov0" title="0">{
                params = make(map[string]*string)
                value := "true"
                // This parameter must be set to prevent the auth token from expiring after 4 hours.
                // Details here: https://github.com/snowflakedb/gosnowflake/issues/556
                params["client_session_keep_alive"] = &amp;value
        }</span>

        <span class="cov0" title="0">if s.dsn, err = gosnowflake.DSN(&amp;gosnowflake.Config{
                Account: s.accountIdentifier,
                // Region: The driver extracts the region automatically from the account and I think it doesn't have to be set here
                Password:      password,
                Authenticator: authenticator,
                User:          s.user,
                Role:          role,
                Database:      s.database,
                Warehouse:     warehouse,
                Schema:        s.schema,
                PrivateKey:    s.privateKey,
                Params:        params,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to construct DSN: %s", err)
        }</span>

        <span class="cov0" title="0">return &amp;s, nil</span>
}

//------------------------------------------------------------------------------

func (s *snowflakeWriter) Connect(ctx context.Context) error <span class="cov0" title="0">{
        var err error
        s.db, err = sql.Open("snowflake", s.dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to snowflake: %s", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createJWT creates a new Snowpipe JWT token
// Inspired from https://stackoverflow.com/questions/63598044/snowpipe-rest-api-returning-always-invalid-jwt-token
func (s *snowflakeWriter) createJWT() (string, error) <span class="cov0" title="0">{
        // Need to use the account without the region segment as described in https://stackoverflow.com/questions/65811588/snowflake-jdbc-driver-throws-net-snowflake-client-jdbc-snowflakesqlexception-jw
        qualifiedUsername := strings.ToUpper(s.account + "." + s.user)
        now := s.nowFn().UTC()
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, jwt.MapClaims{
                "iss": qualifiedUsername + "." + s.publicKeyFingerprint,
                "sub": qualifiedUsername,
                "iat": now.Unix(),
                "exp": now.Add(defaultJWTTimeout).Unix(),
        })

        return token.SignedString(s.privateKey)
}</span>

func (s *snowflakeWriter) getSnowpipeInsertURL(snowpipe, requestID string) string <span class="cov0" title="0">{
        query := url.Values{"requestId": []string{requestID}}
        u := url.URL{
                Scheme:   "https",
                Host:     s.accountIdentifier + ".snowflakecomputing.com",
                Path:     path.Join("/v1/data/pipes", fmt.Sprintf("%s.%s.%s", s.database, s.schema, snowpipe), "insertFiles"),
                RawQuery: query.Encode(),
        }
        return u.String()
}</span>

func (s *snowflakeWriter) callSnowpipe(ctx context.Context, snowpipe, requestID, filePath string) error <span class="cov0" title="0">{
        jwtToken, err := s.createJWT()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Snowpipe JWT token: %s", err)
        }</span>

        <span class="cov0" title="0">type File struct {
                Path string `json:"path"`
        }
        reqPayload := struct {
                Files []File `json:"files"`
        }{
                Files: []File{
                        {
                                Path: filePath,
                        },
                },
        }

        buf := bytes.Buffer{}
        if err := json.NewEncoder(&amp;buf).Encode(reqPayload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request body JSON: %s", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, s.getSnowpipeInsertURL(snowpipe, requestID), &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Snowpipe HTTP request: %s", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+jwtToken)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute Snowpipe HTTP request: %s", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("received unexpected Snowpipe response status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var respPayload struct {
                ResponseCode string
        }
        if err = json.NewDecoder(resp.Body).Decode(&amp;respPayload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode Snowpipe HTTP response: %s", err)
        }</span>
        <span class="cov0" title="0">if respPayload.ResponseCode != "SUCCESS" </span><span class="cov0" title="0">{
                return fmt.Errorf("received unexpected Snowpipe response code: %s", respPayload.ResponseCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *snowflakeWriter) WriteBatch(ctx context.Context, batch service.MessageBatch) error <span class="cov0" title="0">{
        s.connMut.Lock()
        defer s.connMut.Unlock()
        if s.db == nil </span><span class="cov0" title="0">{
                return service.ErrNotConnected
        }</span>

        <span class="cov0" title="0">type file struct {
                stage         string
                stagePath     string
                fileName      string
                fileExtension string
                requestID     string
                snowpipe      string
        }

        // Concatenate messages into sub-batches based on matching interpolated fields.
        // TODO: Maybe add a check to ensure that the interpolated snowpipe is consistent across each sub-batch.
        files := map[file][]byte{}
        for _, msg := range batch </span><span class="cov0" title="0">{
                var (
                        f   file
                        err error
                )

                if f.stage, err = s.stage.TryString(msg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get stage: %s", err)
                }</span> else<span class="cov0" title="0"> if f.stage == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("stage cannot be empty: %s", err)
                }</span>

                <span class="cov0" title="0">if f.stagePath, err = s.path.TryString(msg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get stage path: %s", err)
                }</span>

                <span class="cov0" title="0">if f.requestID, err = s.requestID.TryString(msg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get request ID: %s", err)
                }</span>

                <span class="cov0" title="0">if f.fileName, err = s.fileName.TryString(msg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get file: %s", err)
                }</span>

                <span class="cov0" title="0">if f.fileExtension, err = s.fileExtension.TryString(msg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get file extension: %s", err)
                }</span> else<span class="cov0" title="0"> if f.fileExtension == "" </span><span class="cov0" title="0">{
                        f.fileExtension = s.defaultStageFileExtension
                }</span>

                <span class="cov0" title="0">if s.snowpipe != nil </span><span class="cov0" title="0">{
                        if f.snowpipe, err = s.snowpipe.TryString(msg); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get snowpipe: %s", err)
                        }</span>
                }

                <span class="cov0" title="0">msgBytes, err := msg.AsBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get message bytes: %s", err)
                }</span>

                <span class="cov0" title="0">files[f] = append(files[f], msgBytes...)</span>
        }

        // Stage each file in Snowflake and, optionally, call Snowpipe
        <span class="cov0" title="0">for f, fBytes := range files </span><span class="cov0" title="0">{
                requestID := f.requestID
                if requestID == "" </span><span class="cov0" title="0">{
                        uuid, err := s.uuidGenerator.NewV4()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to generate requestID: %s", err)
                        }</span>

                        <span class="cov0" title="0">requestID = uuid.String()</span>
                }

                <span class="cov0" title="0">fileName := f.fileName
                if fileName == "" </span><span class="cov0" title="0">{
                        fileName = requestID
                }</span>

                <span class="cov0" title="0">filePath := path.Join(f.stagePath, fileName+"."+f.fileExtension)

                _, err := s.db.ExecContext(gosnowflake.WithFileStream(
                        gosnowflake.WithFileTransferOptions(ctx, &amp;gosnowflake.SnowflakeFileTransferOptions{RaisePutGetError: true}),
                        bytes.NewReader(fBytes)), fmt.Sprintf(s.putQueryFormat, filePath, path.Join(f.stage, f.stagePath)))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to run query: %s", err)
                }</span>

                <span class="cov0" title="0">if f.snowpipe != "" </span><span class="cov0" title="0">{
                        s.logger.Debugf("Calling Snowpipe with requestId=%s", requestID)

                        if err := s.callSnowpipe(ctx, f.snowpipe, requestID, filePath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to call Snowpipe: %s", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *snowflakeWriter) Close(ctx context.Context) error <span class="cov0" title="0">{
        s.connMut.Lock()
        defer s.connMut.Unlock()

        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package splunk

import (
        _ "embed"
        "github.com/redpanda-data/benthos/v4/public/service"
)

//go:embed template_output.yaml
var outputTemplate []byte

func init() <span class="cov0" title="0">{
        if err := service.RegisterTemplateYAML(string(outputTemplate)); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package gcp_bigtable

import (
        "cloud.google.com/go/auth/credentials"
        "cloud.google.com/go/bigtable"
        "context"
        "encoding/json"
        "fmt"
        "github.com/google/martian/v3/log"
        "github.com/hashicorp/go-multierror"
        "github.com/redpanda-data/benthos/v4/public/bloblang"
        "github.com/redpanda-data/benthos/v4/public/service"
        "google.golang.org/api/option"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func init() <span class="cov1" title="1">{
        err := service.RegisterBatchOutput(
                "gcp_bigtable", GCPBigTableConfig,
                func(conf *service.ParsedConfig, mgr *service.Resources) (service.BatchOutput, service.BatchPolicy, int, error) </span><span class="cov1" title="1">{
                        bPol, err := conf.FieldBatchPolicy("batching")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, service.BatchPolicy{}, 0, err
                        }</span>

                        <span class="cov1" title="1">maxInFlight, err := conf.FieldInt("max_in_flight")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, service.BatchPolicy{}, 0, err
                        }</span>
                        <span class="cov1" title="1">w, err := NewGCPBigTableOutput(conf, mgr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, service.BatchPolicy{}, 0, err
                        }</span>
                        <span class="cov1" title="1">spanOutput, err := conf.WrapBatchOutputExtractTracingSpanMapping("gcp_bigtable", w)
                        return spanOutput, bPol, maxInFlight, err</span>
                })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

var GCPBigTableConfig = service.NewConfigSpec().
        Summary("Write data to a Google Cloud Bigtable table.").
        Description(`

`).
        Beta().
        Categories("Google Cloud").
        Fields(
                service.NewOutputMaxInFlightField().Default(1024),
                service.NewBatchPolicyField("batching"),
        ).
        Fields(
                service.NewStringField("project").Description("The Google Cloud project to write to."),
                service.NewStringField("instance").Description("The Bigtable instance to write to."),
                service.NewStringField("credentials_json").
                        Description("The json credentials used for connecting to the Bigtable instance.").Optional(),
        ).
        Fields(
                service.NewStringField("table").Description("The Bigtable table to write to."),
                service.NewStringField("key").Description("The expression that results in the row key.").Default("this.key"),
                service.NewStringField("data").Description("The expression that results in the row data.").Default("this.without(\"key\")"),
                service.NewStringField("emulated_host_port").Advanced().Description("Connect to an emulated Bigtable instance.").Default(""),
        )

func NewGCPBigTableOutput(conf *service.ParsedConfig, mgr *service.Resources) (*GCPBigTableOutput, error) <span class="cov1" title="1">{
        project, err := conf.FieldString("project")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">instance, err := conf.FieldString("instance")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">table, err := conf.FieldString("table")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rkp, err := conf.FieldString("key")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rke, err := bloblang.Parse(rkp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse row key bloblang query: %w", err)
        }</span>

        <span class="cov1" title="1">rdp, err := conf.FieldString("data")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rde, err := bloblang.Parse(rdp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse row data bloblang query: %w", err)
        }</span>

        <span class="cov1" title="1">emulated, err := conf.FieldString("emulated_host_port")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">credentialsJSON := ""
        if conf.Contains("credentials_json") </span><span class="cov0" title="0">{
                credentialsJSON, err = conf.FieldString("credentials_json")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov1" title="1">return &amp;GCPBigTableOutput{
                project:         project,
                instance:        instance,
                credentialsJSON: credentialsJSON,
                table:           table,
                rke:             rke,
                rde:             rde,
                emulated:        emulated,
                log:             mgr.Logger(),
        }, nil</span>
}

type GCPBigTableOutput struct {
        project         string
        instance        string
        credentialsJSON string
        table           string
        rke             *bloblang.Executor
        rde             *bloblang.Executor
        emulated        string

        c   *bigtable.Client
        t   *bigtable.Table
        log *service.Logger
}

func (g *GCPBigTableOutput) Connect(ctx context.Context) error <span class="cov1" title="1">{
        if g.emulated != "" </span><span class="cov1" title="1">{
                conn, err := grpc.NewClient(
                        g.emulated,
                        grpc.WithTransportCredentials(insecure.NewCredentials()))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">g.c, err = bigtable.NewClient(context.Background(),
                        "fake-project", "fake-instance", option.WithGRPCConn(conn))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                opts := &amp;credentials.DetectOptions{
                        Scopes: []string{
                                bigtable.Scope,
                        },
                }

                var copts []option.ClientOption
                if len(g.credentialsJSON) &gt; 0 </span><span class="cov0" title="0">{
                        log.Infof("Using provided credentials")
                        copts = append(copts, option.WithCredentialsJSON([]byte(g.credentialsJSON)))
                }</span> else<span class="cov0" title="0"> {
                        log.Infof("Using default credentials")
                        creds, err := credentials.DetectDefault(opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">copts = append(copts, option.WithAuthCredentials(creds))</span>
                }

                <span class="cov0" title="0">client, err := bigtable.NewClient(ctx, g.project, g.instance, copts...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">g.c = client</span>
        }

        <span class="cov1" title="1">g.t = g.c.Open(g.table)
        return nil</span>
}

func (g *GCPBigTableOutput) WriteBatch(ctx context.Context, batch service.MessageBatch) error <span class="cov1" title="1">{
        rks, err := asRowKeys(batch, g.rke)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract row keys: %w", err)
        }</span>

        <span class="cov1" title="1">muts, err := asMutations(batch, g.rde)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract mutations: %w", err)
        }</span>

        <span class="cov1" title="1">errs, err := g.t.ApplyBulk(ctx, rks, muts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;multierror.Error{Errors: errs}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (g *GCPBigTableOutput) Close(ctx context.Context) error <span class="cov1" title="1">{
        if g.c != nil </span><span class="cov1" title="1">{
                return g.c.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func asRowKeys(batch service.MessageBatch, rke *bloblang.Executor) ([]string, error) <span class="cov1" title="1">{
        var result []string
        for _, msg := range batch </span><span class="cov1" title="1">{
                st, err := msg.AsStructured()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">s, err := rke.Query(st)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">if s == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">ss, ok := s.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to extract row key: expected string but got %T", s)
                }</span>

                <span class="cov1" title="1">result = append(result, ss)</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

func asMutations(batch service.MessageBatch, rde *bloblang.Executor) ([]*bigtable.Mutation, error) <span class="cov1" title="1">{
        var result []*bigtable.Mutation

        for _, msg := range batch </span><span class="cov1" title="1">{
                mut, err := asMutation(msg, rde)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">if mut != nil </span><span class="cov1" title="1">{
                        result = append(result, mut)
                }</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

func asMutation(msg *service.Message, rde *bloblang.Executor) (*bigtable.Mutation, error) <span class="cov1" title="1">{
        st, err := msg.AsStructured()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">m, err := rde.Query(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if m == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">data, ok := m.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid message format: expected the message root to be map[string]interface{} but got %T", m)
        }</span>

        <span class="cov1" title="1">mut := bigtable.NewMutation()
        for fk, fv := range data </span><span class="cov5" title="2">{
                fvm, ok := fv.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid message format: expected family %q to be a map[string]interface{} but got %T", fk, fv)
                }</span>

                <span class="cov5" title="2">for ck, cv := range fvm </span><span class="cov10" title="4">{
                        b, err := json.Marshal(cv)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal value for column %q: %w", ck, err)
                        }</span>

                        <span class="cov10" title="4">mut.Set(fk, ck, bigtable.Now(), b)</span>
                }
        }

        <span class="cov1" title="1">return mut, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package change_stream

import (
        "context"
        "github.com/redpanda-data/benthos/v4/public/service"
        "github.com/wombatwisdom/wombat/public/components/mongodb"
)

func inputConfig() *service.ConfigSpec <span class="cov0" title="0">{
        return service.NewConfigSpec().
                Stable().
                Categories("Services").
                Summary("Consume the MongoDB ChangeStream.").
                Description(`This input is capable of reading change events from a MongoDB client, database, or collection.
When a database as well as a collection is provided, only changes to that collection will be read.
When only a database is provided, changes to all collections in that database will be read.
When neither a database nor a collection is provided, changes to all databases and collections will be read.
`).
                Fields(mongodb.Fields...).
                Field(service.NewStringField("database").Description("The database to watch.").Optional().Default("")).
                Field(service.NewStringField("collection").Description("The collection to watch.").Optional().Default("")).
                Field(service.NewAutoRetryNacksToggleField())
}</span>

func init() <span class="cov0" title="0">{
        err := service.RegisterInput(
                "mongodb_change_stream", inputConfig(),
                func(conf *service.ParsedConfig, mgr *service.Resources) (service.Input, error) </span><span class="cov0" title="0">{
                        input, err := newChangeStreamInput(conf, mgr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return service.AutoRetryNacksToggled(conf, input)</span>
                })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func newChangeStreamInput(conf *service.ParsedConfig, mgr *service.Resources) (*changeStreamInput, error) <span class="cov0" title="0">{
        mcfg, err := mongodb.ConfigFromParsed(conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">opts := ChangeStreamReaderOptions{
                Config: *mcfg,
        }

        opts.Database, err = conf.FieldString("database")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">opts.Collection, err = conf.FieldString("collection")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;changeStreamInput{
                reader: NewChangeStreamReader(opts),
        }, nil</span>
}

type changeStreamInput struct {
        reader *ChangeStreamReader
}

func (c *changeStreamInput) Connect(ctx context.Context) error <span class="cov0" title="0">{
        return c.reader.Connect(ctx)
}</span>

func (c *changeStreamInput) Read(ctx context.Context) (*service.Message, service.AckFunc, error) <span class="cov0" title="0">{
        if c.reader == nil </span><span class="cov0" title="0">{
                return nil, nil, service.ErrNotConnected
        }</span>

        <span class="cov0" title="0">msg, err := c.reader.Read(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return msg, func(ctx context.Context, err error) error </span><span class="cov0" title="0">{
                return err
        }</span>, nil
}

func (c *changeStreamInput) Close(ctx context.Context) error <span class="cov0" title="0">{
        return c.reader.Close(ctx)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package change_stream

import (
        "context"
        "errors"
        "fmt"
        "github.com/redpanda-data/benthos/v4/public/service"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"

        "github.com/wombatwisdom/wombat/public/components/mongodb"
        mdb "go.mongodb.org/mongo-driver/mongo"
)

const (
        IdHeader = "mongodb_change_stream_id"
)

type ChangeStreamReaderOptions struct {
        mongodb.Config

        Database   string `json:"database"`
        Collection string `json:"collection"`
}

func (o ChangeStreamReaderOptions) ChangeStream(ctx context.Context, c *mdb.Client) (*mdb.ChangeStream, error) <span class="cov0" title="0">{
        if o.Database != "" </span><span class="cov0" title="0">{
                db := c.Database(o.Database)
                if db == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("database not found: %s", o.Database)
                }</span>

                <span class="cov0" title="0">if o.Collection != "" </span><span class="cov0" title="0">{
                        // -- watch collection
                        col := db.Collection(o.Collection)
                        if col == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("collection not found: %s", o.Collection)
                        }</span>
                        <span class="cov0" title="0">return col.Watch(ctx, []options.ChangeStreamOptions{})</span>
                } else<span class="cov0" title="0"> {
                        // -- watch database
                        return db.Watch(ctx, []options.ChangeStreamOptions{})
                }</span>
        } else<span class="cov0" title="0"> {
                // -- watch client
                return c.Watch(ctx, []options.ChangeStreamOptions{})
        }</span>
}

type ChangeStreamReader struct {
        cfg ChangeStreamReaderOptions

        c  *mdb.Client
        cs *mdb.ChangeStream
}

func NewChangeStreamReader(options ChangeStreamReaderOptions) *ChangeStreamReader <span class="cov0" title="0">{
        return &amp;ChangeStreamReader{
                cfg: options,
        }
}</span>

func (r *ChangeStreamReader) Connect(ctx context.Context) error <span class="cov0" title="0">{
        var err error

        r.c, err = r.cfg.NewClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create client: %w", err)
        }</span>

        <span class="cov0" title="0">r.cs, err = r.cfg.ChangeStream(ctx, r.c)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create change stream: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ChangeStreamReader) Close(ctx context.Context) error <span class="cov0" title="0">{
        var err error
        if r.cs != nil </span><span class="cov0" title="0">{
                err = errors.Join(r.cs.Close(ctx))
        }</span>

        <span class="cov0" title="0">if r.c != nil </span><span class="cov0" title="0">{
                err = errors.Join(r.c.Disconnect(ctx))
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (r *ChangeStreamReader) Read(ctx context.Context) (*service.Message, error) <span class="cov0" title="0">{
        if r.cs == nil </span><span class="cov0" title="0">{
                return nil, errors.New("change stream not connected")
        }</span>

        <span class="cov0" title="0">avail := r.cs.Next(ctx)
        if !avail </span><span class="cov0" title="0">{
                return nil, service.ErrEndOfInput
        }</span>

        // -- read next change
        <span class="cov0" title="0">b, err := bson.MarshalExtJSON(r.cs.Current, false, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal change: %w", err)
        }</span>

        <span class="cov0" title="0">msg := service.NewMessage(b)
        msg.MetaSet(IdHeader, fmt.Sprintf("%d", r.cs.ID()))

        return msg, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mongodb

import (
        "context"
        "fmt"
        "github.com/redpanda-data/benthos/v4/public/service"
        mdb "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var Fields = []*service.ConfigField{
        service.NewStringField("uri").Description("MongoDB connection URI"),
}

func ConfigFromParsed(conf *service.ParsedConfig) (*Config, error) <span class="cov0" title="0">{
        uri, err := conf.FieldString("uri")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                Uri: uri,
        }, nil</span>
}

type Config struct {
        Uri string `json:"uri"`
}

func (c *Config) NewClient(ctx context.Context) (*mdb.Client, error) <span class="cov0" title="0">{
        if c.Uri == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("uri is required")
        }</span>

        <span class="cov0" title="0">opts := options.Client().ApplyURI(c.Uri)

        return mdb.Connect(ctx, opts)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package nats

import (
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/nats-io/nats.go"
        "github.com/nats-io/nkeys"

        "github.com/redpanda-data/benthos/v4/public/service"
)

func authDescription() string <span class="cov1" title="2">{
        return `

## Authentication

There are several components within Wombat which uses NATS services. You will find that each of these components
support optional advanced authentication parameters for [https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth](NKeys)
and [https://docs.nats.io/using-nats/developer/connecting/creds](User Credentials).

See an [https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt](in-depth tutorial).

### NKey file

The NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured
with a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey
configured in the ` + "`nkey_file`" + ` field.

[https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth](More details).

### User credentials

NATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an [https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens](user JWT)
and a corresponding [https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth](NKey secret) when connecting to a server
which is configured to use this authentication scheme.

The ` + "`user_credentials_file`" + ` field should point to a file containing both the private key and the JWT and can be
generated with the [https://docs.nats.io/nats-tools/nsc](nsc tool).

Alternatively, the ` + "`user_jwt`" + ` field can contain a plain text JWT and the ` + "`user_nkey_seed`" + `can contain
the plain text NKey Seed.

[https://docs.nats.io/using-nats/developer/connecting/creds](More details).`
}</span>

func authFieldSpec() *service.ConfigField <span class="cov1" title="2">{
        return service.NewObjectField("auth",
                service.NewStringField("nkey_file").
                        Description("An optional file containing a NKey seed.").
                        Example("./seed.nk").
                        Optional(),
                service.NewStringField("user_credentials_file").
                        Description("An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.").
                        Example("./user.creds").
                        Optional(),
                service.NewStringField("user_jwt").
                        Description("An optional plain text user JWT (given along with the corresponding user NKey Seed).").
                        Secret().
                        Optional(),
                service.NewStringField("user_nkey_seed").
                        Description("An optional plain text user NKey Seed (given along with the corresponding user JWT).").
                        Secret().
                        Optional(),
        ).Description("Optional configuration of NATS authentication parameters.").
                Advanced()
}</span>

type authConfig struct {
        NKeyFile            string
        UserCredentialsFile string
        UserJWT             string
        UserNkeySeed        string
}

//------------------------------------------------------------------------------

func authConfToOptions(auth authConfig, fs *service.FS) []nats.Option <span class="cov1" title="1">{
        var opts []nats.Option
        if auth.NKeyFile != "" </span><span class="cov0" title="0">{
                if opt, err := nats.NkeyOptionFromSeed(auth.NKeyFile); err != nil </span><span class="cov0" title="0">{
                        opts = append(opts, func(*nats.Options) error </span><span class="cov0" title="0">{ return err }</span>)
                } else<span class="cov0" title="0"> {
                        opts = append(opts, opt)
                }</span>
        }

        // Previously we used nats.UserCredentials to authenticate. In order to
        // support a custom FS implementation in our NATS components, we needed to
        // switch to the nats.UserJWT option, while still preserving the behaviour
        // of the nats.UserCredentials option, which includes things like path
        // expansing, home directory support and wiping credentials held in memory
        <span class="cov1" title="1">if auth.UserCredentialsFile != "" </span><span class="cov1" title="1">{
                opts = append(opts, nats.UserJWT(
                        userJWTHandler(auth.UserCredentialsFile, fs),
                        sigHandler(auth.UserCredentialsFile, fs),
                ))
        }</span>

        <span class="cov1" title="1">if auth.UserJWT != "" &amp;&amp; auth.UserNkeySeed != "" </span><span class="cov0" title="0">{
                opts = append(opts, nats.UserJWTAndSeed(
                        auth.UserJWT, auth.UserNkeySeed,
                ))
        }</span>

        <span class="cov1" title="1">return opts</span>
}

// AuthFromParsedConfig attempts to extract an auth config from a ParsedConfig.
func AuthFromParsedConfig(p *service.ParsedConfig) (c authConfig, err error) <span class="cov0" title="0">{
        if p.Contains("nkey_file") </span><span class="cov0" title="0">{
                if c.NKeyFile, err = p.FieldString("nkey_file"); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">if p.Contains("user_credentials_file") </span><span class="cov0" title="0">{
                if c.UserCredentialsFile, err = p.FieldString("user_credentials_file"); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">if p.Contains("user_jwt") || p.Contains("user_nkey_seed") </span><span class="cov0" title="0">{
                if !p.Contains("user_jwt") </span><span class="cov0" title="0">{
                        err = errors.New("missing auth.user_jwt config field")
                        return
                }</span>
                <span class="cov0" title="0">if !p.Contains("user_nkey_seed") </span><span class="cov0" title="0">{
                        err = errors.New("missing auth.user_nkey_seed config field")
                        return
                }</span>
                <span class="cov0" title="0">if c.UserJWT, err = p.FieldString("user_jwt"); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if c.UserNkeySeed, err = p.FieldString("user_nkey_seed"); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func userJWTHandler(filename string, fs *service.FS) nats.UserJWTHandler <span class="cov1" title="1">{
        return func() (string, error) </span><span class="cov1" title="2">{
                contents, err := loadFileContents(filename, fs)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="2">defer wipeSlice(contents)

                return nkeys.ParseDecoratedJWT(contents)</span>
        }
}

func sigHandler(filename string, fs *service.FS) nats.SignatureHandler <span class="cov1" title="1">{
        return func(nonce []byte) ([]byte, error) </span><span class="cov1" title="1">{
                contents, err := loadFileContents(filename, fs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">defer wipeSlice(contents)

                kp, err := nkeys.ParseDecoratedNKey(contents)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to extract key pair from file %q: %v", filename, err)
                }</span>
                <span class="cov1" title="1">defer kp.Wipe()

                sig, _ := kp.Sign(nonce)
                return sig, nil</span>
        }
}

// Just wipe slice with 'x', for clearing contents of creds or nkey seed file.
func wipeSlice(buf []byte) <span class="cov2" title="3">{
        for i := range buf </span><span class="cov10" title="3222">{
                buf[i] = 'x'
        }</span>
}

func expandPath(p string) (string, error) <span class="cov2" title="3">{
        p = os.ExpandEnv(p)

        if !strings.HasPrefix(p, "~") </span><span class="cov2" title="3">{
                return p, nil
        }</span>

        <span class="cov0" title="0">home, err := homeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return filepath.Join(home, p[1:]), nil</span>
}

func homeDir() (string, error) <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                homeDrive, homePath := os.Getenv("HOMEDRIVE"), os.Getenv("HOMEPATH")
                userProfile := os.Getenv("USERPROFILE")

                var home string
                if homeDrive == "" || homePath == "" </span><span class="cov0" title="0">{
                        if userProfile == "" </span><span class="cov0" title="0">{
                                return "", errors.New("nats: failed to get home dir, require %HOMEDRIVE% and %HOMEPATH% or %USERPROFILE%")
                        }</span>
                        <span class="cov0" title="0">home = userProfile</span>
                } else<span class="cov0" title="0"> {
                        home = filepath.Join(homeDrive, homePath)
                }</span>

                <span class="cov0" title="0">return home, nil</span>
        }

        <span class="cov0" title="0">home := os.Getenv("HOME")
        if home == "" </span><span class="cov0" title="0">{
                return "", errors.New("nats: failed to get home dir, require $HOME")
        }</span>
        <span class="cov0" title="0">return home, nil</span>
}

func loadFileContents(filename string, fs *service.FS) ([]byte, error) <span class="cov2" title="3">{
        path, err := expandPath(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">f, err := fs.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="3">defer f.Close()

        return io.ReadAll(f)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package nats

import (
        "context"
        "crypto/tls"
        "strings"

        "github.com/nats-io/nats.go"

        "github.com/redpanda-data/benthos/v4/public/service"
)

// I've split the connection fields into two, which allows us to put tls and
// auth further down the fields stack. This is literally just polish for the
// docs.
func connectionHeadFields() []*service.ConfigField <span class="cov10" title="2">{
        return []*service.ConfigField{
                service.NewStringListField("urls").
                        Description("A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.").
                        Example([]string{"nats://127.0.0.1:4222"}).
                        Example([]string{"nats://username:password@127.0.0.1:4222"}),
        }
}</span>

func connectionTailFields() []*service.ConfigField <span class="cov10" title="2">{
        return []*service.ConfigField{
                service.NewTLSToggledField("tls"),
                authFieldSpec(),
        }
}</span>

type connectionDetails struct {
        label    string
        logger   *service.Logger
        tlsConf  *tls.Config
        authConf authConfig
        fs       *service.FS
        urls     string
}

func connectionDetailsFromParsed(conf *service.ParsedConfig, mgr *service.Resources) (c connectionDetails, err error) <span class="cov0" title="0">{
        c.label = mgr.Label()
        c.fs = mgr.FS()
        c.logger = mgr.Logger()

        var urlList []string
        if urlList, err = conf.FieldStringList("urls"); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">c.urls = strings.Join(urlList, ",")

        var tlsEnabled bool
        if c.tlsConf, tlsEnabled, err = conf.FieldTLSToggled("tls"); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !tlsEnabled </span><span class="cov0" title="0">{
                c.tlsConf = nil
        }</span>

        <span class="cov0" title="0">if c.authConf, err = AuthFromParsedConfig(conf.Namespace("auth")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

func (c *connectionDetails) get(_ context.Context, extraOpts ...nats.Option) (*nats.Conn, error) <span class="cov0" title="0">{
        var opts []nats.Option
        if c.tlsConf != nil </span><span class="cov0" title="0">{
                opts = append(opts, nats.Secure(c.tlsConf))
        }</span>
        <span class="cov0" title="0">opts = append(opts, nats.Name(c.label))
        opts = append(opts, errorHandlerOption(c.logger))
        opts = append(opts, authConfToOptions(c.authConf, c.fs)...)
        opts = append(opts, extraOpts...)
        return nats.Connect(c.urls, opts...)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package nats

import (
        "github.com/redpanda-data/benthos/v4/public/service"
)

func connectionNameDescription() string <span class="cov10" title="2">{
        return `## Connection name

When monitoring and managing a production NATS system, it is often useful to
know which connection a message was send/received from. This can be achieved by
setting the connection name option when creating a NATS connection.

Wombat will automatically set the connection name based off the label of the given
NATS component, so that monitoring tools between NATS and Wombat can stay in sync.
`
}</span>

func inputTracingDocs() *service.ConfigField <span class="cov1" title="1">{
        return service.NewExtractTracingSpanMappingField()
}</span>
func outputTracingDocs() *service.ConfigField <span class="cov1" title="1">{
        return service.NewInjectTracingSpanMappingField()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package nats

import (
        "github.com/nats-io/nats.go"

        "github.com/redpanda-data/benthos/v4/public/service"
)

func errorHandlerOption(logger *service.Logger) nats.Option <span class="cov0" title="0">{
        return nats.ErrorHandler(func(nc *nats.Conn, sub *nats.Subscription, err error) </span><span class="cov0" title="0">{
                if nc != nil </span><span class="cov0" title="0">{
                        logger = logger.With("connection-status", nc.Status())
                }</span>
                <span class="cov0" title="0">if sub != nil </span><span class="cov0" title="0">{
                        logger = logger.With("subject", sub.Subject)
                        if c, err := sub.ConsumerInfo(); err == nil </span><span class="cov0" title="0">{
                                logger = logger.With("consumer", c.Name)
                        }</span>
                }
                <span class="cov0" title="0">logger.Errorf("nats operation failed: %v\n", err)</span>
        })
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package nats

import (
        "context"
        "fmt"
        "github.com/nats-io/nats.go/jetstream"
        "strconv"
        "sync"
        "time"

        "github.com/nats-io/nats.go"

        "github.com/Jeffail/shutdown"

        "github.com/redpanda-data/benthos/v4/public/service"
)

func natsJetStreamInputConfig() *service.ConfigSpec <span class="cov8" title="1">{
        return service.NewConfigSpec().
                Stable().
                Categories("Services").
                Summary("Reads messages from NATS JetStream subjects.").
                Description(`
## Consume mirrored streams

In the case where a stream being consumed is mirrored from a different JetStream domain the stream cannot be resolved 
from the subject name alone, and so the stream name as well as the subject (if applicable) must both be specified.

## Metadata

This input adds the following metadata fields to each message:

` + "```text" + `
- nats_subject
- nats_sequence_stream
- nats_sequence_consumer
- nats_num_delivered
- nats_num_pending
- nats_domain
- nats_timestamp_unix_nano
` + "```" + `

` + connectionNameDescription() + authDescription()).
                Fields(connectionHeadFields()...).
                Field(service.NewStringField("name").Description("The name of the consumer")).
                Field(service.NewBoolField("bind").
                        Description("Indicates whether the input should use an existing consumer").
                        Default(false).
                        Optional()).
                Field(service.NewStringField("stream").
                        Description("The stream to consume from")).
                Field(service.NewStringListField("filter_subjects").
                        Description("The list of subjects to filter on").
                        Optional().
                        Example("foo.bar.baz").Example("foo.*.baz").Example("foo.bar.*").Example("foo.&gt;")).
                Field(service.NewStringAnnotatedEnumField("deliver", map[string]string{
                        "all":               "Deliver all available messages.",
                        "last":              "Deliver starting with the last published messages.",
                        "last_per_subject":  "Deliver starting with the last published message per subject.",
                        "new":               "Deliver starting from now, not taking into account any previous messages.",
                        "by_start_time":     "Deliver starting with messages published after a specific time.",
                        "by_start_sequence": "Deliver starting with messages published after a specific sequence number.",
                }).
                        Description("Determines which messages to deliver when consuming without a durable subscriber.").
                        Default("all")).
                Field(service.NewIntField("start_sequence").Description("The start sequence when using the `by_start_seqyuence` deliver policy").Optional()).
                Field(service.NewStringField("start_time").Description("The start time when using the `by_start_time` deliver policy. Should be in RFC3339 format").Optional()).
                Field(service.NewStringField("ack_wait").
                        Description("The maximum amount of time NATS server should wait for an ack from consumer.").
                        Advanced().
                        Default("30s").
                        Example("100ms").
                        Example("5m")).
                Field(service.NewIntField("max_ack_pending").
                        Description("The maximum number of outstanding acks to be allowed before consuming is halted.").
                        Advanced().
                        Default(1024)).
                Field(service.NewIntField("batch_size").
                        Description("The maximum number of messages to consume in a single batch").
                        Default(1)).
                Field(service.NewDurationField("flush_wait").
                        Description("the amount of time to wait for a new message before closing an incomplete batch").
                        Default("100ms")).
                Field(service.NewDurationField("nak_delay").
                        Description("The amount of time to wait before reattempting to deliver a message that was NAK'd").
                        Optional().
                        Advanced()).
                Fields(connectionTailFields()...).
                Field(inputTracingDocs())
}</span>

func init() <span class="cov8" title="1">{
        err := service.RegisterBatchInput(
                "nats_jetstream_batched", natsJetStreamInputConfig(),
                func(conf *service.ParsedConfig, mgr *service.Resources) (service.BatchInput, error) </span><span class="cov0" title="0">{
                        input, err := newJetStreamReaderFromConfig(conf, mgr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return conf.WrapBatchInputExtractTracingSpanMapping("nats_jetstream_batched", input)</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

//------------------------------------------------------------------------------

type jetStreamReader struct {
        connDetails connectionDetails

        bind      bool
        stream    string
        cfg       jetstream.ConsumerConfig
        batchSize int
        flushWait time.Duration
        nakDelay  *time.Duration

        log *service.Logger

        connMut  sync.Mutex
        natsConn *nats.Conn
        consumer jetstream.Consumer

        shutSig *shutdown.Signaller
}

func newJetStreamReaderFromConfig(conf *service.ParsedConfig, mgr *service.Resources) (*jetStreamReader, error) <span class="cov0" title="0">{
        j := jetStreamReader{
                log:     mgr.Logger(),
                shutSig: shutdown.NewSignaller(),
                cfg:     jetstream.ConsumerConfig{},
        }

        var err error
        if j.connDetails, err = connectionDetailsFromParsed(conf, mgr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">j.cfg.Name, err = conf.FieldString("name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">j.bind, err = conf.FieldBool("bind")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">j.stream, err = conf.FieldString("stream")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">deliver, err := conf.FieldString("deliver")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch deliver </span>{
        case "all":<span class="cov0" title="0">
                j.cfg.DeliverPolicy = jetstream.DeliverAllPolicy</span>
        case "last":<span class="cov0" title="0">
                j.cfg.DeliverPolicy = jetstream.DeliverLastPolicy</span>
        case "last_per_subject":<span class="cov0" title="0">
                j.cfg.DeliverPolicy = jetstream.DeliverLastPerSubjectPolicy</span>
        case "new":<span class="cov0" title="0">
                j.cfg.DeliverPolicy = jetstream.DeliverNewPolicy</span>
        case "by_start_time":<span class="cov0" title="0">
                j.cfg.DeliverPolicy = jetstream.DeliverByStartTimePolicy
                st, err := conf.FieldString("start_time")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">startTime, err := time.Parse(time.RFC3339, st)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse start time: %v", err)
                }</span>

                <span class="cov0" title="0">j.cfg.OptStartTime = &amp;startTime</span>

        case "by_start_sequence":<span class="cov0" title="0">
                j.cfg.DeliverPolicy = jetstream.DeliverByStartSequencePolicy
                // get the start sequence as well
                ss, err := conf.FieldInt("start_sequence")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">j.cfg.OptStartSeq = uint64(ss)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("deliver option %v was not recognised", deliver)</span>
        }

        <span class="cov0" title="0">subs, err := conf.FieldStringList("filter_subjects")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(subs) &gt; 1 </span><span class="cov0" title="0">{
                j.cfg.FilterSubjects = subs
        }</span> else<span class="cov0" title="0"> if len(subs) == 1 </span><span class="cov0" title="0">{
                j.cfg.FilterSubject = subs[0]
        }</span>

        <span class="cov0" title="0">ackWaitStr, err := conf.FieldString("ack_wait")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if ackWaitStr != "" </span><span class="cov0" title="0">{
                j.cfg.AckWait, err = time.ParseDuration(ackWaitStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse ack wait duration: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if j.cfg.MaxAckPending, err = conf.FieldInt("max_ack_pending"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if j.batchSize, err = conf.FieldInt("batch_size"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if j.flushWait, err = conf.FieldDuration("flush_wait"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if conf.Contains("nak_delay") </span><span class="cov0" title="0">{
                delay, err := conf.FieldDuration("nak_delay")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">j.nakDelay = &amp;delay</span>
        }

        <span class="cov0" title="0">return &amp;j, nil</span>
}

//------------------------------------------------------------------------------

func (j *jetStreamReader) Connect(ctx context.Context) (err error) <span class="cov0" title="0">{
        j.connMut.Lock()
        defer j.connMut.Unlock()

        if j.natsConn != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var natsConn *nats.Conn

        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if natsConn != nil </span><span class="cov0" title="0">{
                                natsConn.Close()
                        }</span>
                }
        }()

        <span class="cov0" title="0">if natsConn, err = j.connDetails.get(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">jCtx, err := jetstream.New(natsConn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if j.bind </span><span class="cov0" title="0">{
                j.consumer, err = jCtx.Consumer(ctx, j.stream, j.cfg.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to bind consumer %q: %w", j.cfg.Name, err)
                }</span>
        } else<span class="cov0" title="0"> {
                j.consumer, err = jCtx.CreateOrUpdateConsumer(ctx, j.stream, j.cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create consumer %q: %w", j.cfg.Name, err)
                }</span>
        }

        <span class="cov0" title="0">j.natsConn = natsConn
        return nil</span>
}

func (j *jetStreamReader) disconnect() <span class="cov0" title="0">{
        j.connMut.Lock()
        defer j.connMut.Unlock()

        j.consumer = nil
        if j.natsConn != nil </span><span class="cov0" title="0">{
                j.natsConn.Close()
                j.natsConn = nil
        }</span>
}

func (j *jetStreamReader) ReadBatch(ctx context.Context) (service.MessageBatch, service.AckFunc, error) <span class="cov0" title="0">{
        if j.consumer == nil </span><span class="cov0" title="0">{
                return nil, nil, service.ErrNotConnected
        }</span>

        <span class="cov0" title="0">msgs, err := j.consumer.Fetch(j.batchSize, jetstream.FetchMaxWait(j.flushWait))
        if err != nil </span><span class="cov0" title="0">{
                //if errors.Is(err, nats.ErrTimeout) || errors.Is(err, context.DeadlineExceeded) {
                //        break
                //}
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if msgs.Error() != nil </span><span class="cov0" title="0">{
                return nil, nil, msgs.Error()
        }</span>

        <span class="cov0" title="0">var ackers []service.AckFunc
        var batch service.MessageBatch
        for msg := range msgs.Messages() </span><span class="cov0" title="0">{
                ackers = append(ackers, func(ctx context.Context, res error) error </span><span class="cov0" title="0">{
                        if res == nil </span><span class="cov0" title="0">{
                                return msg.Ack()
                        }</span>

                        <span class="cov0" title="0">if j.nakDelay != nil </span><span class="cov0" title="0">{
                                return msg.NakWithDelay(*j.nakDelay)
                        }</span> else<span class="cov0" title="0"> {
                                return msg.Nak()
                        }</span>
                })
                <span class="cov0" title="0">batch = append(batch, convertMessage(msg))</span>
        }

        <span class="cov0" title="0">return batch, func(ctx context.Context, res error) error </span><span class="cov0" title="0">{
                for _, msg := range ackers </span><span class="cov0" title="0">{
                        if err := msg(ctx, res); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to ack message: %v", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }, nil
}

func (j *jetStreamReader) Close(ctx context.Context) error <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                j.disconnect()
                j.shutSig.TriggerHasStopped()
        }</span>()
        <span class="cov0" title="0">select </span>{
        case &lt;-j.shutSig.HasStoppedChan():<span class="cov0" title="0"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func convertMessage(m jetstream.Msg) *service.Message <span class="cov0" title="0">{
        msg := service.NewMessage(m.Data())
        msg.MetaSet("nats_subject", m.Subject())

        metadata, err := m.Metadata()
        if err == nil </span><span class="cov0" title="0">{
                msg.MetaSet("nats_sequence_stream", strconv.Itoa(int(metadata.Sequence.Stream)))
                msg.MetaSet("nats_sequence_consumer", strconv.Itoa(int(metadata.Sequence.Consumer)))
                msg.MetaSet("nats_num_delivered", strconv.Itoa(int(metadata.NumDelivered)))
                msg.MetaSet("nats_num_pending", strconv.Itoa(int(metadata.NumPending)))
                msg.MetaSet("nats_domain", metadata.Domain)
                msg.MetaSet("nats_timestamp_unix_nano", strconv.Itoa(int(metadata.Timestamp.UnixNano())))
        }</span>

        <span class="cov0" title="0">for k := range m.Headers() </span><span class="cov0" title="0">{
                v := m.Headers().Get(k)
                if v != "" </span><span class="cov0" title="0">{
                        msg.MetaSet(k, v)
                }</span>
        }

        <span class="cov0" title="0">return msg</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package nats

import (
        "context"
        "fmt"
        "github.com/nats-io/nats.go/jetstream"
        "sync"

        "github.com/nats-io/nats.go"

        "github.com/Jeffail/shutdown"

        "github.com/redpanda-data/benthos/v4/public/service"
)

func natsJetStreamOutputConfig() *service.ConfigSpec <span class="cov8" title="1">{
        return service.NewConfigSpec().
                Stable().
                Categories("Services").
                Summary("Write messages to a NATS JetStream subject.").
                Description(connectionNameDescription() + authDescription()).
                Fields(connectionHeadFields()...).
                Field(service.NewInterpolatedStringField("subject").
                        Description("A subject to write to.").
                        Example("foo.bar.baz").
                        Example(`${! meta("kafka_topic") }`).
                        Example(`foo.${! json("meta.type") }`)).
                Field(service.NewInterpolatedStringMapField("headers").
                        Description("Explicit message headers to add to messages.").
                        Default(map[string]any{}).
                        Example(map[string]any{
                                "Content-Type": "application/json",
                                "Timestamp":    `${!meta("Timestamp")}`,
                        }).Version("4.1.0")).
                Field(service.NewMetadataFilterField("metadata").
                        Description("Determine which (if any) metadata values should be added to messages as headers.").
                        Optional()).
                Field(service.NewOutputMaxInFlightField().
                        Default(1024)).
                Fields(service.NewBatchPolicyField("batching")).
                Fields(connectionTailFields()...).
                Field(outputTracingDocs())
}</span>

func init() <span class="cov8" title="1">{
        err := service.RegisterBatchOutput(
                "nats_jetstream_batched", natsJetStreamOutputConfig(),

                func(conf *service.ParsedConfig, mgr *service.Resources) (service.BatchOutput, service.BatchPolicy, int, error) </span><span class="cov0" title="0">{
                        bPol, err := conf.FieldBatchPolicy("batching")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, service.BatchPolicy{}, 0, err
                        }</span>

                        <span class="cov0" title="0">maxInFlight, err := conf.FieldInt("max_in_flight")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, service.BatchPolicy{}, 0, err
                        }</span>
                        <span class="cov0" title="0">w, err := newJetStreamWriterFromConfig(conf, mgr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, service.BatchPolicy{}, 0, err
                        }</span>
                        <span class="cov0" title="0">spanOutput, err := conf.WrapBatchOutputExtractTracingSpanMapping("nats_jetstream_batched", w)
                        return spanOutput, bPol, maxInFlight, err</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

//------------------------------------------------------------------------------

type jetStreamOutput struct {
        connDetails   connectionDetails
        subjectStrRaw string
        subjectStr    *service.InterpolatedString
        headers       map[string]*service.InterpolatedString
        metaFilter    *service.MetadataFilter

        log *service.Logger

        connMut  sync.Mutex
        natsConn *nats.Conn
        js       jetstream.JetStream

        shutSig *shutdown.Signaller
}

func newJetStreamWriterFromConfig(conf *service.ParsedConfig, mgr *service.Resources) (*jetStreamOutput, error) <span class="cov0" title="0">{
        j := jetStreamOutput{
                log:     mgr.Logger(),
                shutSig: shutdown.NewSignaller(),
        }

        var err error
        if j.connDetails, err = connectionDetailsFromParsed(conf, mgr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if j.subjectStrRaw, err = conf.FieldString("subject"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if j.subjectStr, err = conf.FieldInterpolatedString("subject"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if j.headers, err = conf.FieldInterpolatedStringMap("headers"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if conf.Contains("metadata") </span><span class="cov0" title="0">{
                if j.metaFilter, err = conf.FieldMetadataFilter("metadata"); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return &amp;j, nil</span>
}

//------------------------------------------------------------------------------

func (j *jetStreamOutput) Connect(ctx context.Context) (err error) <span class="cov0" title="0">{
        j.connMut.Lock()
        defer j.connMut.Unlock()

        if j.natsConn != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil &amp;&amp; j.natsConn != nil </span><span class="cov0" title="0">{
                        j.natsConn.Close()
                }</span>
        }()

        <span class="cov0" title="0">if j.natsConn, err = j.connDetails.get(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if j.js, err = jetstream.New(j.natsConn); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (j *jetStreamOutput) disconnect() <span class="cov0" title="0">{
        j.connMut.Lock()
        defer j.connMut.Unlock()

        if j.natsConn != nil </span><span class="cov0" title="0">{
                j.natsConn.Close()
                j.natsConn = nil
        }</span>
        <span class="cov0" title="0">j.js = nil</span>
}

//------------------------------------------------------------------------------

func (j *jetStreamOutput) WriteBatch(ctx context.Context, batch service.MessageBatch) error <span class="cov0" title="0">{
        if j.js == nil </span><span class="cov0" title="0">{
                return service.ErrNotConnected
        }</span>

        <span class="cov0" title="0">var pafs []jetstream.PubAckFuture

        for _, msg := range batch </span><span class="cov0" title="0">{
                nmsg, err := j.convertMsg(msg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">paf, err := j.js.PublishMsgAsync(nmsg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">pafs = append(pafs, paf)</span>
        }

        // -- wait for the acks to come back
        <span class="cov0" title="0">&lt;-j.js.PublishAsyncComplete()

        // -- run through the list of acks and check for errors. If an error occured, return it.
        for _, paf := range pafs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-paf.Ok():<span class="cov0" title="0"></span>
                case err := &lt;-paf.Err():<span class="cov0" title="0">
                        return err</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (j *jetStreamOutput) Close(ctx context.Context) error <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                j.disconnect()
                j.shutSig.TriggerHasStopped()
        }</span>()
        <span class="cov0" title="0">select </span>{
        case &lt;-j.shutSig.HasStoppedChan():<span class="cov0" title="0"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (j *jetStreamOutput) convertMsg(msg *service.Message) (*nats.Msg, error) <span class="cov0" title="0">{
        subject, err := j.subjectStr.TryString(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`failed string interpolation on field "subject": %w`, err)
        }</span>

        <span class="cov0" title="0">jsmsg := nats.NewMsg(subject)
        msgBytes, err := msg.AsBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">jsmsg.Data = msgBytes
        for k, v := range j.headers </span><span class="cov0" title="0">{
                value, err := v.TryString(msg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`failed string interpolation on header %q: %w`, k, err)
                }</span>

                <span class="cov0" title="0">jsmsg.Header.Add(k, value)</span>
        }
        <span class="cov0" title="0">_ = j.metaFilter.Walk(msg, func(key, value string) error </span><span class="cov0" title="0">{
                jsmsg.Header.Add(key, value)
                return nil
        }</span>)

        <span class="cov0" title="0">return jsmsg, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
