version: '3'

vars:
  APP_NAME: wombat
  DOCKER_IMAGE: "ghcr.io/wombatwisdom/{{.APP_NAME}}"
  TARGET_DIR: ./target
  TARGET_BIN: "{{.TARGET_DIR}}/bin"
  LD_FLAGS: -w -s
  GO_FLAGS: ""
  GOMAXPROCS: 1
  GOEXE:
    sh: go env GOEXE
  DATE:
    sh: 'date +"%Y-%m-%dT%H:%M:%SZ"'
  VERSION:
    sh: git describe --tags 2> /dev/null || echo "v0.0.0"
  VER_CUT:
    sh: echo {{.VERSION}} | cut -c2-
  VER_MAJOR:
    sh: echo {{.VER_CUT}} | cut -d. -f1
  VER_MINOR:
    sh: echo {{.VER_CUT}} | cut -d. -f2
  VER_PATCH:
    sh: echo {{.VER_CUT}} | cut -d. -f3
  VER_RC:
    sh: echo {{.VER_PATCH}} | cut -f2 -d-
  VER_FLAGS: '-X main.Version={{.VERSION}} -X main.DateBuilt={{.DATE}}'

tasks:
  setup:
    desc: Setup development environment
    cmds:
      - go install github.com/goreleaser/goreleaser/v2@latest
      - go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.5.0

  godir:
    cmd: which go

  deps:
    desc: Install dependencies
    cmd: go mod tidy

  build:
    desc: Build the application
    deps:
      - deps
    cmd: go build {{.GO_FLAGS}} -tags "{{.TAGS}}" -ldflags "{{.LD_FLAGS}} {{.VER_FLAGS}}" -o {{.TARGET_BIN}}/{{.APP_NAME}}{{.GOEXE}} ./cmd/{{.APP_NAME}}/*.go

  build:mq:
    desc: Build with IBM MQ support (requires MQ libraries)
    deps:
      - deps
    cmd: CGO_ENABLED=1 go build {{.GO_FLAGS}} -tags mqclient -ldflags "{{.LD_FLAGS}} {{.VER_FLAGS}}" -o {{.TARGET_BIN}}/{{.APP_NAME}}-mq{{.GOEXE}} ./cmd/{{.APP_NAME}}/*.go

  tools:
    desc: Build the tools
    deps:
      - deps
    cmds:
      - go build {{.GO_FLAGS}} -tags "{{.TAGS}}" -ldflags "{{.LD_FLAGS}} {{.VER_FLAGS}}" -o {{.TARGET_BIN}}/docs_gen ./cmd/docs_gen/*.go

  install:
    desc: Install the application
    deps:
      - build
    vars:
      INSTALL_DIR: "{{.GOPATH}}/bin"
    cmds:
      - install -d {{.INSTALL_DIR}}
      - rm -f {{.INSTALL_DIR}}/{{.APP_NAME}}
      - cp {{.TARGET_BIN}}/* {{.INSTALL_DIR}}/

  docker:
    cmds:
      - docker build -f ./Dockerfile . -t {{.DOCKER_IMAGE}}:{{.VER_CUT}}
      - docker tag {{.DOCKER_IMAGE}}:{{.VER_CUT}} {{.DOCKER_IMAGE}}:latest

  fmt:
    cmds:
      - gofmt -w -s .
      - goimports -w -local github.com/wombatwisdom/wombat .
      - go mod tidy

  format:check:
    desc: Check code formatting
    cmds:
      - |
        if [ -n "$(gofmt -l .)" ]; then
          echo "Code is not formatted. Please run 'task fmt'"
          gofmt -l .
          exit 1
        fi

  lint:
    desc: Vet and lint the code
    cmds:
      - go vet {{.GO_FLAGS}} ./...
      - golangci-lint run --timeout 1h --verbose cmd/... internal/... public/...

  check:
    desc: Run all code quality checks
    cmds:
      - task: lint
      - task: format:check
      - task: check:license

  check:license:
    desc: Check for restrictively licensed imports
    cmds:
      - |
        echo "🔍 Checking for restrictive imports..."
        
        # Check Go files for problematic imports
        FOUND_ISSUES=0
        
        # Check for /enterprise/ in import paths
        if grep -r --include="*.go" -E 'import.*"/enterprise/"' . 2>/dev/null; then
          echo "❌ ERROR: Found restrictive imports!"
          FOUND_ISSUES=1
        fi
        
        # Check for /public/components/all
        if grep -r --include="*.go" -E 'github\.com/redpanda-data/connect/v4/public/components/all' . 2>/dev/null; then
          echo "❌ ERROR: Found imports of /public/components/all (contains RCL-licensed enterprise components)"
          echo "   Replace with: github.com/redpanda-data/connect/v4/public/components/community"
          FOUND_ISSUES=1
        fi
        
        # Check for /public/schema
        if grep -r --include="*.go" -E 'github\.com/redpanda-data/connect/v4/public/schema' . 2>/dev/null; then
          echo "❌ ERROR: Found imports of /public/schema (may contain enterprise dependencies)"
          echo "   Replace with: use service.GlobalEnvironment() from benthos directly"
          FOUND_ISSUES=1
        fi
        
        # Check go.mod for non-community RedPanda Connect packages (excluding base module)
        if grep -E 'github\.com/redpanda-data/connect/v4/' go.mod | grep -v '/public/components/community' | grep -v '// indirect'; then
          echo "❌ ERROR: Found non-community RedPanda Connect imports in go.mod"
          echo "   Only use: github.com/redpanda-data/connect/v4/public/components/community"
          FOUND_ISSUES=1
        fi
        
        # Check for any enterprise-specific keywords
        if grep -r --include="*.go" -E 'connect-enterprise|redpanda-enterprise|"rcl"|"RCL"' . 2>/dev/null | grep -v "check:license"; then
          echo "❌ ERROR: Found potential enterprise package references"
          FOUND_ISSUES=1
        fi
        
        if [ $FOUND_ISSUES -eq 0 ]; then
          echo "✅ No restrictive imports found - safe to proceed!"
        else
          echo ""
          echo "📝 Safe imports to use:"
          echo "   - github.com/redpanda-data/benthos/v4/* (MIT licensed)"
          echo "   - github.com/redpanda-data/connect/v4/public/components/community (Apache 2.0)"
          exit 1
        fi

  test:
    desc: Run all tests
    deps:
      - build
    cmds:
      - 'go test {{.GO_FLAGS}} -ldflags "{{.LD_FLAGS}}" -timeout 3m ./...'

  test:all:
    desc: Run all tests including IBM MQ (requires MQ libraries)
    deps:
      - build
    cmds:
      - |
        echo "Running all tests including IBM MQ..."
        CGO_ENABLED=1 go test {{.GO_FLAGS}} -tags mqclient -ldflags "{{.LD_FLAGS}}" -timeout 3m ./...

  test:unit:
    desc: Run the unit tests
    deps:
      - build
    cmds:
      - 'go test {{.GO_FLAGS}} -ldflags "{{.LD_FLAGS}}" -timeout 3m ./...'

  test:unit:all:
    desc: Run unit tests including IBM MQ
    deps:
      - build
    cmds:
      - 'CGO_ENABLED=1 go test {{.GO_FLAGS}} -tags mqclient -ldflags "{{.LD_FLAGS}}" -timeout 3m ./...'

  test:race:
    desc: Run tests with race detector
    deps:
      - build
    cmd: go test {{.GO_FLAGS}} -ldflags "{{.LD_FLAGS}}" -timeout 3m -race ./...

  test:coverage:
    desc: Run tests with coverage report
    deps:
      - build
    cmds:
      - go test {{.GO_FLAGS}} -ldflags "{{.LD_FLAGS}}" -timeout 3m -coverprofile=coverage.out -covermode=atomic ./...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"

  test:coverage:all:
    desc: Run tests with coverage including IBM MQ
    deps:
      - build
    cmds:
      - CGO_ENABLED=1 go test {{.GO_FLAGS}} -tags mqclient -ldflags "{{.LD_FLAGS}}" -timeout 3m -coverprofile=coverage.out -covermode=atomic ./...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"

  test:integration:
    desc: Run integration tests
    cmds:
      - go test -tags integration -v -run '.*Integration$' ./public/components/wombatwisdom/mqtt3/
      - go test -tags integration -v -run TestMongoDBConfigIntegration ./public/components/mongodb/
      - go test -tags integration -v -run TestChangeStreamIntegration ./public/components/mongodb/change_stream/
      - go test -tags integration -v -run TestSplunkIntegration ./internal/impl/splunk/
      - go test -tags integration -v -run TestIntegrationZMQn ./internal/impl/zeromq/
      - go test -tags integration -v -run TestIntegrationNatsPullConsumer ./public/components/nats/

  test:integration:all:
    desc: Run all integration tests including IBM MQ
    cmds:
      - task: test:integration
      - CGO_ENABLED=1 go test -tags "integration mqclient" -v -run 'TestIntegration' ./public/components/wombatwisdom/ibmmq/

  clean:
    cmds:
      - rm -rf {{.TARGET_DIR}}

  docs:
#    deps:
#      - build
#      - tools
    cmds:
      - go run ./cmd/docs_gen

  # Do not edit. Shared with wombatwisdom/components.
  release:snapshot:
    desc: Create a local snapshot release (no tags)
    env:
      GITHUB_REPOSITORY_OWNER: wombatwisdom
    cmds:
      - goreleaser release --snapshot --clean --skip=publish,docker
  release:check:
    desc: Pre-release checks
    cmds:
      - |
        # Check for uncommitted changes
        if [ -n "$(git status --porcelain)" ]; then
          echo "Error: Uncommitted changes detected. Please commit or stash changes before releasing."
          exit 1
        fi
      - |
        # Check we're on main branch
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [ "$BRANCH" != "main" ]; then
          echo "Error: Releases must be created from main branch. Currently on: $BRANCH"
          exit 1
        fi
      - |
        # Ensure we have latest changes
        git fetch origin main
        if [ $(git rev-list HEAD...origin/main --count) -gt 0 ]; then
          echo "Error: Local main branch is not up to date with origin. Please pull latest changes."
          exit 1
        fi



  release:rc:
    desc: Create a release candidate
    vars:
      CURRENT_TAG:
        sh: git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0"
      NEXT_RC:
        sh: |
          # Get the most recent tag
          current_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          
          # If no tags exist and we got a commit hash, use v0.0.0
          if ! echo "$current_tag" | grep -q '^v[0-9]'; then
            current_tag="v0.0.0"
          fi
          
          if echo "$current_tag" | grep -q "\-rc"; then
            # Extract base version and RC number
            base=$(echo "$current_tag" | sed 's/-rc.*//')
            rc_num=$(echo "$current_tag" | sed 's/.*-rc//')
            next_rc=$((rc_num + 1))
            echo "${base}-rc${next_rc}" | sed 's/^v//'
          else
            # No RC suffix, increment patch version for new RC series
            version=$(echo "$current_tag" | sed 's/^v//')
            major=$(echo "$version" | cut -d. -f1)
            minor=$(echo "$version" | cut -d. -f2)
            patch=$(echo "$version" | cut -d. -f3)
            
            # Increment patch version
            next_patch=$((patch + 1))
            echo "${major}.${minor}.${next_patch}-rc1"
          fi
      TAG_VERSION: "v{{.NEXT_RC}}"
    cmds:
      - task: release:check
      - task: check
      - task: test
      - |
        echo "Creating release candidate: {{.TAG_VERSION}}"

        # Validate version format
        if ! echo "{{.NEXT_RC}}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-rc[0-9]+)?$'; then
          echo "Error: Invalid version format. Expected: X.Y.Z or X.Y.Z-rcN"
          exit 1
        fi

        # Check if tag already exists
        if git rev-parse "{{.TAG_VERSION}}" >/dev/null 2>&1; then
          echo "Error: Tag {{.TAG_VERSION}} already exists"
          exit 1
        fi

        # Create and push tag
        git tag -a "{{.TAG_VERSION}}" -m "Release candidate {{.TAG_VERSION}}"
        git push origin "{{.TAG_VERSION}}"

        echo "✅ Tag {{.TAG_VERSION}} created and pushed"
        echo "GitHub Actions will now create the release using goreleaser"

  release:final:
    desc: Create a final release
    vars:
      CURRENT_TAG:
        sh: git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0"
      FINAL_VERSION:
        sh: |
          current_tag=$(git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0")
          # Remove RC suffix if present
          echo "$current_tag" | sed 's/-rc.*//' | sed 's/^v//'
      TAG_VERSION: "v{{.FINAL_VERSION}}"
    cmds:
      - task: release:check
      - task: check
      - task: test
      - |
        echo "Creating final release: {{.TAG_VERSION}}"
        
        # Validate version format (no RC suffix allowed)
        if ! echo "{{.FINAL_VERSION}}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
          echo "Error: Invalid version format. Expected: X.Y.Z (no RC suffix)"
          exit 1
        fi
        
        # Check if tag already exists
        if git rev-parse "{{.TAG_VERSION}}" >/dev/null 2>&1; then
          echo "Error: Tag {{.TAG_VERSION}} already exists"
          exit 1
        fi
        
        # Create and push tag
        git tag -a "{{.TAG_VERSION}}" -m "Release {{.TAG_VERSION}}"
        git push origin "{{.TAG_VERSION}}"
        
        echo "✅ Tag {{.TAG_VERSION}} created and pushed"
        echo "GitHub Actions will now create the release using goreleaser"

  release:list:
    desc: List recent releases
    cmds:
      - gh release list --limit 20
  release:current:
    desc: Show current version
    cmds:
      - |
        CURRENT=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "v0.0.0")
        echo "Current version: $CURRENT"
        
        # Check if there are commits since last tag
        if [ "$CURRENT" != "v0.0.0" ]; then
          COMMITS_SINCE=$(git rev-list --count $CURRENT..HEAD)
          if [ $COMMITS_SINCE -gt 0 ]; then
            echo "Commits since $CURRENT: $COMMITS_SINCE"
          fi
        fi